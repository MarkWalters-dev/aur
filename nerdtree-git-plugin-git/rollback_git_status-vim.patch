diff --git a/nerdtree_plugin/git_status.vim b/nerdtree_plugin/git_status.vim
index 47cbba2..af1f6c2 100644
--- a/nerdtree_plugin/git_status.vim
+++ b/nerdtree_plugin/git_status.vim
@@ -2,277 +2,233 @@
 " File:        git_status.vim
 " Description: plugin for NERD Tree that provides git status support
 " Maintainer:  Xuyuan Pang <xuyuanp at gmail dot com>
+" Last Change: 4 Apr 2014
 " License:     This program is free software. It comes without any warranty,
 "              to the extent permitted by applicable law. You can redistribute
 "              it and/or modify it under the terms of the Do What The Fuck You
 "              Want To Public License, Version 2, as published by Sam Hocevar.
 "              See http://sam.zoy.org/wtfpl/COPYING for more details.
 " ============================================================================
-scriptencoding utf-8
-
 if exists('g:loaded_nerdtree_git_status')
     finish
 endif
 let g:loaded_nerdtree_git_status = 1
 
-let s:is_win = gitstatus#isWin()
-
-" stolen from nerdtree
-"Function: s:initVariable() function {{{2
-"This function is used to initialise a given variable to a given value. The
-"variable is only initialised if it does not exist prior
-"
-"Args:
-"var: the name of the var to be initialised
-"value: the value to initialise var to
-"
-"Returns:
-"1 if the var is set, 0 otherwise
-function! s:initVariable(var, value) abort
-    if !exists(a:var)
-        exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", 'g') . "'"
-        return 1
-    endif
-    return 0
-endfunction
-
-let s:default_vals = {
-            \ 'g:NERDTreeGitStatusEnable':             1,
-            \ 'g:NERDTreeGitStatusUpdateOnWrite':      1,
-            \ 'g:NERDTreeGitStatusUpdateOnCursorHold': 1,
-            \ 'g:NERDTreeGitStatusShowIgnored':        0,
-            \ 'g:NERDTreeGitStatusUseNerdFonts':       0,
-            \ 'g:NERDTreeGitStatusDirDirtyOnly':       1,
-            \ 'g:NERDTreeGitStatusConcealBrackets':    0,
-            \ 'g:NERDTreeGitStatusAlignIfConceal':     1,
-            \ 'g:NERDTreeGitStatusShowClean':          0,
-            \ 'g:NERDTreeGitStatusLogLevel':           2,
-            \ 'g:NERDTreeGitStatusPorcelainVersion':   2,
-            \ 'g:NERDTreeGitStatusCwdOnly':            0,
-            \ 'g:NERDTreeGitStatusMapNextHunk':        ']c',
-            \ 'g:NERDTreeGitStatusMapPrevHunk':        '[c',
-            \ 'g:NERDTreeGitStatusUntrackedFilesMode': 'normal',
-            \ 'g:NERDTreeGitStatusGitBinPath':         'git',
-            \ }
-
-for [s:var, s:value] in items(s:default_vals)
-    call s:initVariable(s:var, s:value)
-endfor
-
-let s:logger = gitstatus#log#NewLogger(g:NERDTreeGitStatusLogLevel)
-
-function! s:deprecated(oldv, newv) abort
-    call s:logger.warning(printf("option '%s' is deprecated, please use '%s'", a:oldv, a:newv))
-endfunction
-
-function! s:migrateVariable(oldv, newv) abort
-    if exists(a:oldv)
-        call s:deprecated(a:oldv, a:newv)
-        exec 'let ' . a:newv . ' = ' . a:oldv
-        return 1
-    endif
-    return 0
-endfunction
-
-let s:need_migrate_vals = {
-            \ 'g:NERDTreeShowGitStatus':      'g:NERDTreeGitStatusEnable',
-            \ 'g:NERDTreeUpdateOnWrite':      'g:NERDTreeGitStatusUpdateOnWrite',
-            \ 'g:NERDTreeMapNextHunk':        'g:NERDTreeGitStatusMapNextHunk',
-            \ 'g:NERDTreeMapPrevHunk':        'g:NERDTreeGitStatusMapPrevHunk',
-            \ 'g:NERDTreeShowIgnoredStatus':  'g:NERDTreeGitStatusShowIgnored',
-            \ 'g:NERDTreeIndicatorMapCustom': 'g:NERDTreeGitStatusIndicatorMapCustom',
-            \ }
-
-for [s:oldv, s:newv] in items(s:need_migrate_vals)
-    call s:migrateVariable(s:oldv, s:newv)
-endfor
-
-if !g:NERDTreeGitStatusEnable
-    finish
+if !exists('g:NERDTreeShowGitStatus')
+    let g:NERDTreeShowGitStatus = 1
 endif
 
-if !executable(g:NERDTreeGitStatusGitBinPath)
-    call s:logger.error('git command not found')
+if g:NERDTreeShowGitStatus == 0
     finish
 endif
 
-" FUNCTION: path2str
-" This function is used to format nerdtree.Path.
-" For Windows, returns in format 'C:/path/to/file'
-"
-" ARGS:
-" path: nerdtree.Path
-"
-" RETURNS:
-" absolute path
-function! s:path2str(path) abort
-    return gitstatus#util#FormatPath(a:path)
-endfunction
-
-" disable ProhibitUnusedVariable because these three functions used to callback
-" vint: -ProhibitUnusedVariable
-function! s:onGitWorkdirSuccessCB(job) abort
-    let g:NTGitWorkdir = split(join(a:job.chunks, ''), "\n")[0]
-    call s:logger.debug(printf("'%s' is in a git repo: '%s'", a:job.opts.cwd, g:NTGitWorkdir))
-    call s:enableLiveUpdate()
-
-    call s:refreshGitStatus('init', g:NTGitWorkdir)
-endfunction
+if !exists('g:NERDTreeMapNextHunk')
+    let g:NERDTreeMapNextHunk = ']c'
+endif
 
-function! s:onGitWorkdirFailedCB(job) abort
-    let l:errormsg = join(a:job.err_chunks, '')
-    if l:errormsg =~# 'fatal: Not a git repository'
-        call s:logger.debug(printf("'%s' is not in a git repo", a:job.opts.cwd))
-    endif
-    call s:disableLiveUpdate()
-    unlet! g:NTGitWorkdir
-endfunction
+if !exists('g:NERDTreeMapPrevHunk')
+    let g:NERDTreeMapPrevHunk = '[c'
+endif
 
-function! s:getGitWorkdir(ntRoot) abort
-    call gitstatus#job#Spawn('git-workdir',
-                \ s:buildGitWorkdirCommand(a:ntRoot),
-                \ {
-                \ 'on_success_cb': function('s:onGitWorkdirSuccessCB'),
-                \ 'on_failed_cb': function('s:onGitWorkdirFailedCB'),
-                \ 'cwd': a:ntRoot,
-                \ })
-endfunction
-" vint: +ProhibitUnusedVariable
+if !exists('g:NERDTreeUpdateOnWrite')
+    let g:NERDTreeUpdateOnWrite = 1
+endif
 
-function! s:buildGitWorkdirCommand(root) abort
-    return gitstatus#util#BuildGitWorkdirCommand(a:root, g:)
-endfunction
+if !exists('g:NERDTreeUpdateOnCursorHold')
+    let g:NERDTreeUpdateOnCursorHold = 1
+endif
 
-function! s:buildGitStatusCommand(workdir) abort
-    return gitstatus#util#BuildGitStatusCommand(a:workdir, g:)
-endfunction
+if !exists('g:NERDTreeShowIgnoredStatus')
+    let g:NERDTreeShowIgnoredStatus = 0
+endif
 
-function! s:refreshGitStatus(name, workdir) abort
-    let l:opts =  {
-                \ 'on_failed_cb': function('s:onGitStatusFailedCB'),
-                \ 'on_success_cb': function('s:onGitStatusSuccessCB'),
-                \ 'cwd': a:workdir
+if !exists('s:NERDTreeIndicatorMap')
+    let s:NERDTreeIndicatorMap = {
+                \ 'Modified'  : '✹',
+                \ 'Staged'    : '✚',
+                \ 'Untracked' : '✭',
+                \ 'Renamed'   : '➜',
+                \ 'Unmerged'  : '═',
+                \ 'Deleted'   : '✖',
+                \ 'Dirty'     : '✗',
+                \ 'Clean'     : '✔︎',
+                \ 'Ignored'   : '☒',
+                \ 'Unknown'   : '?'
                 \ }
-    let l:job = gitstatus#job#Spawn(a:name, s:buildGitStatusCommand(a:workdir), l:opts)
-    return l:job
-endfunction
+endif
 
-" vint: -ProhibitUnusedVariable
-function! s:onGitStatusSuccessCB(job) abort
-    if !exists('g:NTGitWorkdir') || g:NTGitWorkdir !=# a:job.opts.cwd
-        call s:logger.debug(printf("git workdir has changed: '%s' -> '%s'", a:job.opts.cwd, get(g:, 'NTGitWorkdir', '')))
-        return
-    endif
-    let l:output = join(a:job.chunks, '')
-    let l:lines = split(l:output, "\n")
-    let l:cache = gitstatus#util#ParseGitStatusLines(a:job.opts.cwd, l:lines, g:)
-
-    try
-        call s:listener.SetNext(l:cache)
-        call s:listener.TryUpdateNERDTreeUI()
-    catch
-    endtry
-endfunction
 
-function! s:onGitStatusFailedCB(job) abort
-    let l:errormsg = join(a:job.err_chunks, '')
-    if l:errormsg =~# "error: option `porcelain' takes no value"
-        call s:logger.error(printf("'git status' command failed, please upgrade your git binary('v2.11.0' or higher) or set option 'g:NERDTreeGitStatusPorcelainVersion' to 1 in vimrc"))
-        call s:disableLiveUpdate()
-        unlet! g:NTGitWorkdir
-    elseif l:errormsg =~# '^warning: could not open .* Permission denied'
-        call s:onGitStatusSuccessCB(a:job)
-    else
-        call s:logger.error(printf('job[%s] failed: %s', a:job.name, l:errormsg))
+function! NERDTreeGitStatusRefreshListener(event)
+    if !exists('b:NOT_A_GIT_REPOSITORY')
+        call g:NERDTreeGitStatusRefresh()
+    endif
+    let l:path = a:event.subject
+    let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
+    call l:path.flagSet.clearFlags('git')
+    if l:flag !=# ''
+        call l:path.flagSet.addFlag('git', l:flag)
     endif
 endfunction
 
-" FUNCTION: s:onCursorHold(fname) {{{2
-function! s:onCursorHold(fname)
-    " Do not update when a special buffer is selected
-    if !empty(&l:buftype)
+" FUNCTION: g:NERDTreeGitStatusRefresh() {{{2
+" refresh cached git status
+function! g:NERDTreeGitStatusRefresh()
+    let b:NERDTreeCachedGitFileStatus = {}
+    let b:NERDTreeCachedGitDirtyDir   = {}
+    let b:NOT_A_GIT_REPOSITORY        = 1
+
+    let l:root = fnamemodify(b:NERDTree.root.path.str(), ':p:gs?\\?/?:S')
+    let l:gitcmd = 'git -c color.status=false -C ' . l:root . ' status -s'
+    if g:NERDTreeShowIgnoredStatus
+        let l:gitcmd = l:gitcmd . ' --ignored'
+    endif
+    if exists('g:NERDTreeGitStatusIgnoreSubmodules')
+        let l:gitcmd = l:gitcmd . ' --ignore-submodules'
+        if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
+            let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
+        endif
+    endif
+    let l:statusesStr = system(l:gitcmd)
+    let l:statusesSplit = split(l:statusesStr, '\n')
+    if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
+        let l:statusesSplit = []
         return
     endif
-    let l:fname = s:is_win ?
-                \ substitute(a:fname, '\', '/', 'g') :
-                \ a:fname
+    let b:NOT_A_GIT_REPOSITORY = 0
+
+    for l:statusLine in l:statusesSplit
+        " cache git status of files
+        let l:pathStr = substitute(l:statusLine, '...', '', '')
+        let l:pathSplit = split(l:pathStr, ' -> ')
+        if len(l:pathSplit) == 2
+            call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
+            let l:pathStr = l:pathSplit[1]
+        else
+            let l:pathStr = l:pathSplit[0]
+        endif
+        let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
+        if l:pathStr =~# '\.\./.*'
+            continue
+        endif
+        let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
+        let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
+
+        if l:statusKey == 'Ignored'
+            if isdirectory(l:pathStr)
+                let b:NERDTreeCachedGitDirtyDir[fnameescape(l:pathStr)] = l:statusKey
+            endif
+        else
+            call s:NERDTreeCacheDirtyDir(l:pathStr)
+        endif
+    endfor
+endfunction
 
-    if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
+function! s:NERDTreeCacheDirtyDir(pathStr)
+    " cache dirty dir
+    let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
+    if l:dirtyPath =~# '\.\./.*'
         return
     endif
+    let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
+    while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
+        let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
+        let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
+    endwhile
+endfunction
 
-    let l:job = s:refreshGitStatus('cursor-hold', g:NTGitWorkdir)
-    call s:logger.debug('run cursor-hold job: ' . l:job.id)
+function! s:NERDTreeTrimDoubleQuotes(pathStr)
+    let l:toReturn = substitute(a:pathStr, '^"', '', '')
+    let l:toReturn = substitute(l:toReturn, '"$', '', '')
+    return l:toReturn
 endfunction
 
-" FUNCTION: s:onFileUpdate(fname) {{{2
-function! s:onFileUpdate(fname)
-    let l:fname = s:is_win ?
-                \ substitute(a:fname, '\', '/', 'g') :
-                \ a:fname
-    if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
-        return
+" FUNCTION: g:NERDTreeGetGitStatusPrefix(path) {{{2
+" return the indicator of the path
+" Args: path
+let s:GitStatusCacheTimeExpiry = 2
+let s:GitStatusCacheTime = 0
+function! g:NERDTreeGetGitStatusPrefix(path)
+    if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
+        let s:GitStatusCacheTime = localtime()
+        call g:NERDTreeGitStatusRefresh()
+    endif
+    let l:pathStr = a:path.str()
+    let l:cwd = b:NERDTree.root.path.str() . nerdtree#slash()
+    if nerdtree#runningWindows()
+        let l:pathStr = a:path.WinToUnixPath(l:pathStr)
+        let l:cwd = a:path.WinToUnixPath(l:cwd)
     endif
-    let l:job = s:refreshGitStatus('file-update', g:NTGitWorkdir)
-    call s:logger.debug('run file-update job: ' . l:job.id)
+    let l:cwd = substitute(l:cwd, '\~', '\\~', 'g')
+    let l:pathStr = substitute(l:pathStr, l:cwd, '', '')
+    let l:statusKey = ''
+    if a:path.isDirectory
+        let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
+    else
+        let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
+    endif
+    return s:NERDTreeGetIndicator(l:statusKey)
 endfunction
-" vint: +ProhibitUnusedVariable
 
-function! s:hasPrefix(text, prefix) abort
-    return len(a:text) >= len(a:prefix) && a:text[:len(a:prefix)-1] ==# a:prefix
+" FUNCTION: s:NERDTreeGetCWDGitStatus() {{{2
+" return the indicator of cwd
+function! g:NERDTreeGetCWDGitStatus()
+    if b:NOT_A_GIT_REPOSITORY
+        return ''
+    elseif b:NERDTreeCachedGitDirtyDir == {} && b:NERDTreeCachedGitFileStatus == {}
+        return s:NERDTreeGetIndicator('Clean')
+    endif
+    return s:NERDTreeGetIndicator('Dirty')
 endfunction
 
-function! s:setupNERDTreeListeners(listener) abort
-    call g:NERDTreePathNotifier.AddListener('init', a:listener.OnInit)
-    call g:NERDTreePathNotifier.AddListener('refresh', a:listener.OnRefresh)
-    call g:NERDTreePathNotifier.AddListener('refreshFlags', a:listener.OnRefreshFlags)
+function! s:NERDTreeGetIndicator(statusKey)
+    if exists('g:NERDTreeIndicatorMapCustom')
+        let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
+        if l:indicator !=# ''
+            return l:indicator
+        endif
+    endif
+    let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
+    if l:indicator !=# ''
+        return l:indicator
+    endif
+    return ''
 endfunction
 
-" FUNCTION: s:findHunk(node, direction)
-" Args:
-" node: the current node
-" direction: next(>0) or prev(<0)
-"
-" Returns:
-" lineNum if the hunk found, -1 otherwise
-function! s:findHunk(node, direction) abort
-    let l:ui = b:NERDTree.ui
-    let l:rootLn = l:ui.getRootLineNum()
-    let l:totalLn = line('$')
-    let l:currLn = l:ui.getLineNum(a:node)
-    let l:currLn = l:currLn <= l:rootLn ? l:rootLn+1 : l:currLn
-    let l:step = a:direction > 0 ? 1 : -1
-    let l:lines = a:direction > 0 ?
-                \ range(l:currLn+1, l:totalLn, l:step) + range(l:rootLn+1, l:currLn-1, l:step) :
-                \ range(l:currLn-1, l:rootLn+1, l:step) + range(l:totalLn, l:currLn+1, l:step)
-    for l:ln in l:lines
-        let l:path = s:path2str(l:ui.getPath(l:ln))
-        if s:listener.HasPath(l:path)
-            return l:ln
-        endif
-    endfor
-    return -1
+function! s:NERDTreeGetFileGitStatusKey(us, them)
+    if a:us ==# '?' && a:them ==# '?'
+        return 'Untracked'
+    elseif a:us ==# ' ' && a:them ==# 'M'
+        return 'Modified'
+    elseif a:us =~# '[MAC]'
+        return 'Staged'
+    elseif a:us ==# 'R'
+        return 'Renamed'
+    elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
+        return 'Unmerged'
+    elseif a:them ==# 'D'
+        return 'Deleted'
+    elseif a:us ==# '!'
+        return 'Ignored'
+    else
+        return 'Unknown'
+    endif
 endfunction
 
-" vint: -ProhibitUnusedVariable
 " FUNCTION: s:jumpToNextHunk(node) {{{2
 function! s:jumpToNextHunk(node)
-    let l:ln = s:findHunk(a:node, 1)
-    if l:ln > 0
-        exec '' . l:ln
-        call s:logger.info('Jump to next hunk')
+    let l:position = search('\[[^{RO} ].*\]', '')
+    if l:position
+        call nerdtree#echo('Jump to next hunk ')
     endif
 endfunction
 
 " FUNCTION: s:jumpToPrevHunk(node) {{{2
 function! s:jumpToPrevHunk(node)
-    let l:ln = s:findHunk(a:node, -1)
-    if l:ln > 0
-        exec '' . l:ln
-        call s:logger.info('Jump to prev hunk')
+    let l:position = search('\[[^{RO} ].*\]', 'b')
+    if l:position
+        call nerdtree#echo('Jump to prev hunk ')
     endif
 endfunction
-" vint: +ProhibitUnusedVariable
 
 " Function: s:SID()   {{{2
 function s:SID()
@@ -282,67 +238,121 @@ function s:SID()
     return s:sid
 endfun
 
-" FUNCTION: s:setupNERDTreeKeyMappings {{{2
-function! s:setupNERDTreeKeyMappings()
+" FUNCTION: s:NERDTreeGitStatusKeyMapping {{{2
+function! s:NERDTreeGitStatusKeyMapping()
     let l:s = '<SNR>' . s:SID() . '_'
 
     call NERDTreeAddKeyMap({
-                \ 'key': g:NERDTreeGitStatusMapNextHunk,
-                \ 'scope': 'Node',
-                \ 'callback': l:s.'jumpToNextHunk',
-                \ 'quickhelpText': 'Jump to next git hunk' })
+        \ 'key': g:NERDTreeMapNextHunk,
+        \ 'scope': 'Node',
+        \ 'callback': l:s.'jumpToNextHunk',
+        \ 'quickhelpText': 'Jump to next git hunk' })
 
     call NERDTreeAddKeyMap({
-                \ 'key': g:NERDTreeGitStatusMapPrevHunk,
-                \ 'scope': 'Node',
-                \ 'callback': l:s.'jumpToPrevHunk',
-                \ 'quickhelpText': 'Jump to prev git hunk' })
+        \ 'key': g:NERDTreeMapPrevHunk,
+        \ 'scope': 'Node',
+        \ 'callback': l:s.'jumpToPrevHunk',
+        \ 'quickhelpText': 'Jump to prev git hunk' })
+
 endfunction
 
+augroup nerdtreegitplugin
+    autocmd CursorHold * silent! call s:CursorHoldUpdate()
+augroup END
+" FUNCTION: s:CursorHoldUpdate() {{{2
+function! s:CursorHoldUpdate()
+    if g:NERDTreeUpdateOnCursorHold != 1
+        return
+    endif
 
-" I don't know why, but vint said they are unused.
-" vint: -ProhibitUnusedVariable
-function! s:onNERDTreeDirChanged(path) abort
-    call s:getGitWorkdir(a:path)
-endfunction
+    if !g:NERDTree.IsOpen()
+        return
+    endif
 
-function! s:onNERDTreeInit(path) abort
-    call s:getGitWorkdir(a:path)
+    " Do not update when a special buffer is selected
+    if !empty(&l:buftype)
+        return
+    endif
+
+    let l:winnr = winnr()
+    let l:altwinnr = winnr('#')
+
+    call g:NERDTree.CursorToTreeWin()
+    call b:NERDTree.root.refreshFlags()
+    call NERDTreeRender()
+
+    exec l:altwinnr . 'wincmd w'
+    exec l:winnr . 'wincmd w'
 endfunction
-" vint: +ProhibitUnusedVariable
 
-function! s:enableLiveUpdate() abort
-    augroup nerdtreegitplugin_liveupdate
-        autocmd!
-        if g:NERDTreeGitStatusUpdateOnWrite
-            autocmd BufWritePost * silent! call s:onFileUpdate(expand('%:p'))
-        endif
+augroup nerdtreegitplugin
+    autocmd BufWritePost * call s:FileUpdate(expand('%:p'))
+augroup END
+" FUNCTION: s:FileUpdate(fname) {{{2
+function! s:FileUpdate(fname)
+    if g:NERDTreeUpdateOnWrite != 1
+        return
+    endif
 
-        if g:NERDTreeGitStatusUpdateOnCursorHold
-            autocmd CursorHold * silent! call s:onCursorHold(expand('%:p'))
-        endif
+    if !g:NERDTree.IsOpen()
+        return
+    endif
 
-        " TODO: is it necessary to pass the buffer name?
-        autocmd User FugitiveChanged silent! call s:onFileUpdate(expand('%:p'))
+    let l:winnr = winnr()
+    let l:altwinnr = winnr('#')
+
+    call g:NERDTree.CursorToTreeWin()
+    let l:node = b:NERDTree.root.findNode(g:NERDTreePath.New(a:fname))
+    if l:node != {}
+        call l:node.refreshFlags()
+        let l:node = l:node.parent
+        while !empty(l:node)
+            call l:node.refreshDirFlags()
+            let l:node = l:node.parent
+        endwhile
+        call NERDTreeRender()
+    endif
 
-        autocmd BufEnter NERD_tree_* if exists('b:NERDTree') |
-                    \ call s:onNERDTreeInit(s:path2str(b:NERDTree.root.path)) | endif
-    augroup end
+    exec l:altwinnr . 'wincmd w'
+    exec l:winnr . 'wincmd w'
 endfunction
 
-function! s:disableLiveUpdate() abort
-    augroup nerdtreegitplugin_liveupdate
-        autocmd!
-    augroup end
-endfunction
+augroup AddHighlighting
+    autocmd FileType nerdtree call s:AddHighlighting()
+augroup END
+function! s:AddHighlighting()
+    let l:synmap = {
+                \ 'NERDTreeGitStatusModified'    : s:NERDTreeGetIndicator('Modified'),
+                \ 'NERDTreeGitStatusStaged'      : s:NERDTreeGetIndicator('Staged'),
+                \ 'NERDTreeGitStatusUntracked'   : s:NERDTreeGetIndicator('Untracked'),
+                \ 'NERDTreeGitStatusRenamed'     : s:NERDTreeGetIndicator('Renamed'),
+                \ 'NERDTreeGitStatusIgnored'     : s:NERDTreeGetIndicator('Ignored'),
+                \ 'NERDTreeGitStatusDirDirty'    : s:NERDTreeGetIndicator('Dirty'),
+                \ 'NERDTreeGitStatusDirClean'    : s:NERDTreeGetIndicator('Clean')
+                \ }
 
-augroup nerdtreegitplugin
-    autocmd!
-    autocmd User NERDTreeInit call s:onNERDTreeInit(s:path2str(b:NERDTree.root.path))
-    autocmd User NERDTreeNewRoot call s:onNERDTreeDirChanged(s:path2str(b:NERDTree.root.path))
-augroup end
+    for l:name in keys(l:synmap)
+        exec 'syn match ' . l:name . ' #\[\@<=' . escape(l:synmap[l:name], '~') . '\]\@=# containedin=NERDTreeFlags'
+    endfor
 
-call s:setupNERDTreeKeyMappings()
+    hi def link NERDTreeGitStatusModified Special
+    hi def link NERDTreeGitStatusStaged Function
+    hi def link NERDTreeGitStatusRenamed Title
+    hi def link NERDTreeGitStatusUnmerged Label
+    hi def link NERDTreeGitStatusUntracked Comment
+    hi def link NERDTreeGitStatusDirDirty Tag
+    hi def link NERDTreeGitStatusDirClean DiffAdd
+    " TODO: use diff color
+    hi def link NERDTreeGitStatusIgnored DiffAdd
+endfunction
 
-let s:listener = gitstatus#listener#New(g:)
-call s:setupNERDTreeListeners(s:listener)
+function! s:SetupListeners()
+    call g:NERDTreePathNotifier.AddListener('init', 'NERDTreeGitStatusRefreshListener')
+    call g:NERDTreePathNotifier.AddListener('refresh', 'NERDTreeGitStatusRefreshListener')
+    call g:NERDTreePathNotifier.AddListener('refreshFlags', 'NERDTreeGitStatusRefreshListener')
+endfunction
+
+if g:NERDTreeShowGitStatus && executable('git')
+    call s:NERDTreeGitStatusKeyMapping()
+    call s:SetupListeners()
+endif
