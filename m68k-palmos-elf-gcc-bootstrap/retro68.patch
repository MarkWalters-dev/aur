diff -aurN gcc-12.2.0/gcc/c/c-decl.cc gcc-12.2.0-retro68/gcc/c/c-decl.cc
--- gcc-12.2.0/gcc/c/c-decl.cc	2022-08-19 15:09:52.536661908 +0700
+++ gcc-12.2.0-retro68/gcc/c/c-decl.cc	2024-10-31 17:12:51.703665751 +0700
@@ -5141,7 +5141,8 @@
 	break;
 
       case FUNCTION_DECL:
-	error ("function %qD is initialized like a variable", decl);
+	//error ("function %qD is initialized like a variable", decl);
+        // Retro68: a function defined by inline opcodes does not count as initialized.
 	initialized = false;
 	break;
 
diff -aurN gcc-12.2.0/gcc/c/c-parser.cc gcc-12.2.0-retro68/gcc/c/c-parser.cc
--- gcc-12.2.0/gcc/c/c-parser.cc	2022-08-19 15:09:52.540661961 +0700
+++ gcc-12.2.0-retro68/gcc/c/c-parser.cc	2024-10-31 17:12:51.706999117 +0700
@@ -1619,6 +1619,8 @@
   (c_parser *, struct c_declspecs *);
 static location_t c_parser_parse_rtl_body (c_parser *, char *);
 
+static tree c_parser_inline_opcodes(c_parser *);
+
 /* Parse a translation unit (C90 6.7, C99 6.9, C11 6.9).
 
    translation-unit:
@@ -2264,23 +2266,31 @@
 		  /* The declaration of the variable is in effect while
 		     its initializer is parsed.  */
 		  d = start_decl (declarator, specs, true,
-				  chainon (postfix_attrs, all_prefix_attrs));
+			          chainon (postfix_attrs, all_prefix_attrs));
 		  if (!d)
 		    d = error_mark_node;
 		  if (omp_declare_simd_clauses)
 		    c_finish_omp_declare_simd (parser, d, NULL_TREE,
 					       omp_declare_simd_clauses);
-		  init_loc = c_parser_peek_token (parser)->location;
-		  rich_location richloc (line_table, init_loc);
-		  start_init (d, asm_name, global_bindings_p (), &richloc);
-		  /* A parameter is initialized, which is invalid.  Don't
-		     attempt to instrument the initializer.  */
-		  int flag_sanitize_save = flag_sanitize;
-		  if (TREE_CODE (d) == PARM_DECL)
-		    flag_sanitize = 0;
-		  init = c_parser_initializer (parser);
-		  flag_sanitize = flag_sanitize_save;
-		  finish_init ();
+		  if(TREE_CODE(d) == FUNCTION_DECL)
+                    {
+                      tree rawinline_attr = c_parser_inline_opcodes(parser);
+                      decl_attributes (&d, rawinline_attr, 0);
+                    }
+                  else
+                    {
+                      init_loc = c_parser_peek_token (parser)->location;
+		      rich_location richloc (line_table, init_loc);
+		      start_init (d, asm_name, global_bindings_p (), &richloc);
+		      /* A parameter is initialized, which is invalid.  Don't
+		         attempt to instrument the initializer.  */
+		      int flag_sanitize_save = flag_sanitize;
+		      if (TREE_CODE (d) == PARM_DECL)
+		        flag_sanitize = 0;
+		      init = c_parser_initializer (parser);
+		      flag_sanitize = flag_sanitize_save;
+		      finish_init ();
+                    }
 		}
 	      if (oacc_routine_data)
 		c_finish_oacc_routine (oacc_routine_data, d, false);
@@ -7330,6 +7340,7 @@
   location_t loc, last_tok_loc;
   enum cpp_ttype type;
   tree value, string_tree;
+  bool pascal_string = false;
 
   tok = c_parser_peek_token (parser);
   loc = tok->location;
@@ -7410,11 +7421,23 @@
     warning (OPT_Wtraditional,
 	     "traditional C rejects string constant concatenation");
 
+  if (!strncmp((const char*)strs[0].text, "\"\\p", 3))
+    {
+       pascal_string = true;
+       /* replace \p by a valid escape sequence */
+       ((unsigned char*)strs[0].text)[2] = 'n';
+    }
+
   if ((type == CPP_STRING || wide_ok)
       && ((translate
 	  ? cpp_interpret_string : cpp_interpret_string_notranslate)
 	  (parse_in, strs, count, &istr, type)))
     {
+      if (pascal_string)
+        {
+          /* put the real string length in */
+          ((unsigned char*)istr.text)[0] = (unsigned char) (istr.len - 2);
+        }
       value = build_string (istr.len, (const char *) istr.text);
       free (CONST_CAST (unsigned char *, istr.text));
       if (count > 1)
@@ -7465,7 +7488,10 @@
     default:
     case CPP_STRING:
     case CPP_UTF8STRING:
-      TREE_TYPE (value) = char_array_type_node;
+      if (pascal_string)
+        TREE_TYPE (value) = uchar_array_type_node;
+      else
+        TREE_TYPE (value) = char_array_type_node;
       break;
     case CPP_STRING16:
       TREE_TYPE (value) = char16_array_type_node;
@@ -23359,6 +23385,33 @@
   the_parser = NULL;
 }
 
+static tree c_parser_inline_opcodes(c_parser * parser)
+{
+  tree attr_args;
+  vec<tree, va_gc> *expr_list;
+  bool braced = false;
+    
+  braced = c_parser_next_token_is(parser, CPP_OPEN_BRACE);
+  if(braced)
+    c_parser_consume_token(parser);
+  
+  expr_list = c_parser_expr_list (parser, false, true,
+                                  NULL, NULL, NULL, NULL);
+  attr_args = build_tree_list_vec (expr_list);
+  release_tree_vector (expr_list);
+  
+  if(braced)
+    {
+      if(c_parser_next_token_is(parser, CPP_CLOSE_BRACE))
+        c_parser_consume_token(parser);
+      else
+        c_parser_error (parser, "expected %<}%>");
+    }
+  
+  return build_tree_list (
+		canonicalize_attr_name(get_identifier("__raw_inline__")), attr_args);
+}
+
 /* Parse the body of a function declaration marked with "__RTL".
 
    The RTL parser works on the level of characters read from a
diff -aurN gcc-12.2.0/gcc/calls.cc gcc-12.2.0-retro68/gcc/calls.cc
--- gcc-12.2.0/gcc/calls.cc	2022-08-19 15:09:52.544662011 +0700
+++ gcc-12.2.0-retro68/gcc/calls.cc	2024-10-31 17:12:51.706999117 +0700
@@ -293,17 +293,29 @@
     }
   else
     {
-      /* funexp could be a SYMBOL_REF represents a function pointer which is
-	 of ptr_mode.  In this case, it should be converted into address mode
-	 to be a valid address for memory rtx pattern.  See PR 64971.  */
-      if (GET_MODE (funexp) != Pmode)
-	funexp = convert_memory_address (Pmode, funexp);
+      int is_magic = 0;
 
-      if (!(flags & ECF_SIBCALL))
-	{
-	  if (!NO_FUNCTION_CSE && optimize && ! flag_no_function_cse)
-	    funexp = force_reg (Pmode, funexp);
-	}
+      if (fndecl_or_type)
+        {
+          tree fntype = TREE_TYPE(fndecl_or_type);
+          if(fntype && lookup_attribute ("raw_inline", TYPE_ATTRIBUTES (fntype)))
+            is_magic = 1;
+        }
+    
+      if (!is_magic)
+        {
+          /* funexp could be a SYMBOL_REF represents a function pointer which is
+	     of ptr_mode.  In this case, it should be converted into address mode
+	     to be a valid address for memory rtx pattern.  See PR 64971.  */
+          if (GET_MODE (funexp) != Pmode)
+	    funexp = convert_memory_address (Pmode, funexp);
+
+          if (!(flags & ECF_SIBCALL))
+	    {
+	      if (!NO_FUNCTION_CSE && optimize && ! flag_no_function_cse)
+	        funexp = force_reg (Pmode, funexp);
+	    }
+        }
     }
 
   if (static_chain_value != 0
@@ -1275,7 +1287,8 @@
 				 rtx *old_stack_level,
 				 poly_int64_pod *old_pending_adj,
 				 int *must_preallocate, int *ecf_flags,
-				 bool *may_tailcall, bool call_from_thunk_p)
+				 bool *may_tailcall, bool call_from_thunk_p,
+				 bool reverse_args)
 {
   CUMULATIVE_ARGS *args_so_far_pnt = get_cumulative_args (args_so_far);
   location_t loc = EXPR_LOCATION (exp);
@@ -1283,7 +1296,7 @@
   /* Count arg position in order args appear.  */
   int argpos;
 
-  int i;
+  int i, inc;
 
   args_size->constant = 0;
   args_size->var = 0;
@@ -1291,7 +1304,17 @@
   /* In this loop, we consider args in the order they are written.
      We fill up ARGS from the back.  */
 
-  i = num_actuals - 1;
+  if (!reverse_args)
+    {
+      i = num_actuals - 1, inc = -1;
+      /* In this case, must reverse order of args
+	 so that we compute and push the last arg first.  */
+    }
+  else
+    {
+      i = 0, inc = 1;
+    }
+
   {
     int j = i;
     call_expr_arg_iterator iter;
@@ -1300,7 +1323,7 @@
     if (struct_value_addr_value)
       {
 	args[j].tree_value = struct_value_addr_value;
-	j--;
+	j += inc;
       }
     argpos = 0;
     FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)
@@ -1314,18 +1337,18 @@
 	  {
 	    tree subtype = TREE_TYPE (argtype);
 	    args[j].tree_value = build1 (REALPART_EXPR, subtype, arg);
-	    j--;
+	    j += inc;
 	    args[j].tree_value = build1 (IMAGPART_EXPR, subtype, arg);
 	  }
 	else
 	  args[j].tree_value = arg;
-	j--;
+	j += inc;
 	argpos++;
       }
   }
 
   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */
-  for (argpos = 0; argpos < num_actuals; i--, argpos++)
+  for (argpos = 0; argpos < num_actuals; i += inc, argpos++)
     {
       tree type = TREE_TYPE (args[i].tree_value);
       int unsignedp;
@@ -2699,6 +2722,10 @@
   unsigned HOST_WIDE_INT preferred_unit_stack_boundary;
   /* The static chain value to use for this call.  */
   rtx static_chain_value;
+
+  /* True if this is a call to a pascal-declared function. */
+  bool is_pascal = false;
+
   /* See if this is "nothrow" function call.  */
   if (TREE_NOTHROW (exp))
     flags |= ECF_NOTHROW;
@@ -2723,6 +2750,10 @@
 
   struct_value = targetm.calls.struct_value_rtx (fntype, 0);
 
+#ifdef IS_PASCAL_FUNC
+  is_pascal = IS_PASCAL_FUNC(fntype, fndecl);
+#endif
+
   /* Warn if this value is an aggregate type,
      regardless of which calling convention we are using for it.  */
   if (AGGREGATE_TYPE_P (rettype))
@@ -2940,7 +2971,8 @@
 				   args_so_far, reg_parm_stack_space,
 				   &old_stack_level, &old_pending_adj,
 				   &must_preallocate, &flags,
-				   &try_tail_call, CALL_FROM_THUNK_P (exp));
+				   &try_tail_call, CALL_FROM_THUNK_P (exp),
+				   is_pascal);
 
   if (args_size.var)
     must_preallocate = 1;
@@ -3000,6 +3032,9 @@
   if (must_tail_call)
     try_tail_call = 1;
 
+  if (is_pascal)
+    try_tail_call = 0;
+
   /*  Rest of purposes for tail call optimizations to fail.  */
   if (try_tail_call)
     try_tail_call = can_implement_as_sibling_call_p (exp,
@@ -3431,6 +3466,16 @@
 					      &low_to_save, &high_to_save);
 #endif
 
+      if (is_pascal)
+	{
+	  auto pascal_return_mode = TYPE_MODE (TREE_TYPE (funtype));
+	  poly_uint16 modesize = GET_MODE_SIZE (pascal_return_mode);
+#ifdef PUSH_ROUNDING
+	  modesize = PUSH_ROUNDING (modesize);
+#endif
+	  push_block (gen_int_mode (modesize, Pmode), 0, 0);
+	}
+
       /* Now store (and compute if necessary) all non-register parms.
 	 These come before register parms, since they can require block-moves,
 	 which could clobber the registers used for register parms.
@@ -3519,7 +3564,8 @@
       /* Figure out the register where the value, if any, will come back.  */
       valreg = 0;
       if (TYPE_MODE (rettype) != VOIDmode
-	  && ! structure_value_addr)
+	  && ! structure_value_addr
+	  && ! is_pascal)
 	{
 	  if (pcc_struct_value)
 	    valreg = hard_function_value (build_pointer_type (rettype),
@@ -3615,6 +3661,27 @@
 		   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,
 		   flags, args_so_far);
 
+      if (is_pascal)
+      {
+	if (TYPE_MODE (rettype) != VOIDmode
+	    && ! structure_value_addr)
+	  {
+	    valreg = gen_reg_rtx(TYPE_MODE(rettype));
+
+	    poly_uint16 modesize = GET_MODE_SIZE (GET_MODE (valreg));
+#ifdef PUSH_ROUNDING
+	    modesize = PUSH_ROUNDING (modesize);
+#endif
+	    emit_move_insn(valreg,
+			   gen_rtx_MEM( GET_MODE (valreg),
+					stack_pointer_rtx
+			   ));
+
+	    adjust_stack(gen_int_mode (modesize, Pmode));
+	  }
+	}
+
+
       if (flag_ipa_ra)
 	{
 	  rtx_call_insn *last;
diff -aurN gcc-12.2.0/gcc/c-family/c-common.cc gcc-12.2.0-retro68/gcc/c-family/c-common.cc
--- gcc-12.2.0/gcc/c-family/c-common.cc	2022-08-19 15:09:52.532661858 +0700
+++ gcc-12.2.0-retro68/gcc/c-family/c-common.cc	2024-10-31 17:12:51.700332385 +0700
@@ -783,6 +783,11 @@
       charsz = 1;
       e_type = char_type_node;
     }
+  else if (TREE_TYPE (value) == uchar_array_type_node)
+    {
+      charsz = 1;
+      e_type = unsigned_char_type_node;
+    }
   else if (flag_char8_t && TREE_TYPE (value) == char8_array_type_node)
     {
       charsz = TYPE_PRECISION (char8_type_node) / BITS_PER_UNIT;
@@ -4515,6 +4520,12 @@
   char_array_type_node
     = build_array_type (char_type_node, array_domain_type);
 
+  /* Make a type for arrays of unsigned characters.
+     Needed for "\ppascal string" support.  */
+  uchar_array_type_node
+    = build_array_type (unsigned_char_type_node, array_domain_type);
+
+
   string_type_node = build_pointer_type (char_type_node);
   const_string_type_node
     = build_pointer_type (build_qualified_type
diff -aurN gcc-12.2.0/gcc/c-family/c-common.h gcc-12.2.0-retro68/gcc/c-family/c-common.h
--- gcc-12.2.0/gcc/c-family/c-common.h	2022-08-19 15:09:52.532661858 +0700
+++ gcc-12.2.0-retro68/gcc/c-family/c-common.h	2024-10-31 17:12:51.700332385 +0700
@@ -355,6 +355,7 @@
     CTI_UINTPTR_TYPE,
 
     CTI_CHAR_ARRAY_TYPE,
+    CTI_UCHAR_ARRAY_TYPE,
     CTI_CHAR8_ARRAY_TYPE,
     CTI_CHAR16_ARRAY_TYPE,
     CTI_CHAR32_ARRAY_TYPE,
@@ -513,6 +514,7 @@
 #define truthvalue_false_node		c_global_trees[CTI_TRUTHVALUE_FALSE]
 
 #define char_array_type_node		c_global_trees[CTI_CHAR_ARRAY_TYPE]
+#define uchar_array_type_node		c_global_trees[CTI_UCHAR_ARRAY_TYPE]
 #define char8_array_type_node		c_global_trees[CTI_CHAR8_ARRAY_TYPE]
 #define char16_array_type_node		c_global_trees[CTI_CHAR16_ARRAY_TYPE]
 #define char32_array_type_node		c_global_trees[CTI_CHAR32_ARRAY_TYPE]
diff -aurN gcc-12.2.0/gcc/c-family/c-lex.cc gcc-12.2.0-retro68/gcc/c-family/c-lex.cc
--- gcc-12.2.0/gcc/c-family/c-lex.cc	2022-08-19 15:09:52.532661858 +0700
+++ gcc-12.2.0-retro68/gcc/c-family/c-lex.cc	2024-10-31 17:12:51.700332385 +0700
@@ -1262,6 +1262,8 @@
      zero '@' before each string.  */
   bool objc_at_sign_was_seen = false;
 
+  bool pascal_string = false;
+
  retry:
   tok = cpp_get_token (parse_in);
   switch (tok->type)
@@ -1329,10 +1331,22 @@
     warning (OPT_Wtraditional,
 	     "traditional C rejects string constant concatenation");
 
+  if (!strncmp((const char*)strs[0].text, "\"\\p", 3))
+    {
+       pascal_string = true;
+       /* replace \p by a valid escape sequence */
+       ((unsigned char*)strs[0].text)[2] = 'n';
+    }
+
   if ((translate
        ? cpp_interpret_string : cpp_interpret_string_notranslate)
       (parse_in, strs, concats + 1, &istr, type))
     {
+      if (pascal_string)
+        {
+          /* put the real string length in */
+          ((unsigned char*)istr.text)[0] = (unsigned char) (istr.len - 2);
+        }
       value = build_string (istr.len, (const char *) istr.text);
       free (CONST_CAST (unsigned char *, istr.text));
       if (concats)
@@ -1377,7 +1391,10 @@
     {
     default:
     case CPP_STRING:
-      TREE_TYPE (value) = char_array_type_node;
+      if (pascal_string)
+        TREE_TYPE (value) = uchar_array_type_node;
+      else
+        TREE_TYPE (value) = char_array_type_node;
       break;
     case CPP_UTF8STRING:
       if (flag_char8_t)
diff -aurN gcc-12.2.0/gcc/combine.cc gcc-12.2.0-retro68/gcc/combine.cc
--- gcc-12.2.0/gcc/combine.cc	2022-08-19 15:09:52.548662062 +0700
+++ gcc-12.2.0-retro68/gcc/combine.cc	2024-10-31 17:12:51.710332483 +0700
@@ -14262,10 +14262,10 @@
 	      old_size = fixup_args_size_notes (PREV_INSN (i3), i3, args_size);
 	      /* emit_call_1 adds for !ACCUMULATE_OUTGOING_ARGS
 		 REG_ARGS_SIZE note to all noreturn calls, allow that here.  */
-	      gcc_assert (maybe_ne (old_size, args_size)
+	     /* gcc_assert (maybe_ne (old_size, args_size)
 			  || (CALL_P (i3)
 			      && !ACCUMULATE_OUTGOING_ARGS
-			      && find_reg_note (i3, REG_NORETURN, NULL_RTX)));
+			      && find_reg_note (i3, REG_NORETURN, NULL_RTX))); ### */
 	    }
 	  break;
 
diff -aurN gcc-12.2.0/gcc/combine-stack-adj.cc gcc-12.2.0-retro68/gcc/combine-stack-adj.cc
--- gcc-12.2.0/gcc/combine-stack-adj.cc	2022-08-19 15:09:52.548662062 +0700
+++ gcc-12.2.0-retro68/gcc/combine-stack-adj.cc	2024-10-31 17:12:51.710332483 +0700
@@ -828,7 +828,10 @@
     {
       return rest_of_handle_stack_adjustments ();
     }
-
+  virtual opt_pass *clone ()
+    {
+      return new pass_stack_adjustments(m_ctxt);
+    }
 }; // class pass_stack_adjustments
 
 bool
diff -aurN gcc-12.2.0/gcc/config/m68k/m68k.cc gcc-12.2.0-retro68/gcc/config/m68k/m68k.cc
--- gcc-12.2.0/gcc/config/m68k/m68k.cc	2022-08-19 15:09:52.652663394 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68k.cc	2024-10-31 17:12:52.017002149 +0700
@@ -17,6 +17,9 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#include <string>
+#include <map>
+#include <vector>
 #define IN_TARGET_CODE 1
 
 #include "config.h"
@@ -41,6 +44,7 @@
 #include "output.h"
 #include "insn-attr.h"
 #include "recog.h"
+#include "hashtab.h"
 #include "diagnostic-core.h"
 #include "flags.h"
 #include "expmed.h"
@@ -66,11 +70,16 @@
 #include "optabs.h"
 #include "builtins.h"
 #include "rtl-iter.h"
+#include "stringpool.h"
 #include "toplev.h"
 
 /* This file should be included last.  */
 #include "target-def.h"
 
+
+std::map< std::string, std::vector<int> > pragma_parameter_directives;
+
+
 enum reg_class regno_reg_class[] =
 {
   DATA_REGS, DATA_REGS, DATA_REGS, DATA_REGS,
@@ -190,6 +199,9 @@
 static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
 static enum flt_eval_method
 m68k_excess_precision (enum excess_precision_type);
+
+static tree m68k_mangle_decl_assembler_name (tree decl, tree id);
+static pad_direction m68k_function_arg_padding (machine_mode mode, const_tree type);
 static unsigned int m68k_hard_regno_nregs (unsigned int, machine_mode);
 static bool m68k_hard_regno_mode_ok (unsigned int, machine_mode);
 static bool m68k_modes_tieable_p (machine_mode, machine_mode);
@@ -278,8 +290,8 @@
 #undef TARGET_ATTRIBUTE_TABLE
 #define TARGET_ATTRIBUTE_TABLE m68k_attribute_table
 
-#undef TARGET_PROMOTE_PROTOTYPES
-#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+//#undef TARGET_PROMOTE_PROTOTYPES
+//#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
 
 #undef TARGET_STRUCT_VALUE_RTX
 #define TARGET_STRUCT_VALUE_RTX m68k_struct_value_rtx
@@ -354,6 +366,15 @@
 #undef TARGET_PROMOTE_FUNCTION_MODE
 #define TARGET_PROMOTE_FUNCTION_MODE m68k_promote_function_mode
 
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE m68k_function_value
+
+#undef TARGET_MANGLE_DECL_ASSEMBLER_NAME
+#define TARGET_MANGLE_DECL_ASSEMBLER_NAME m68k_mangle_decl_assembler_name
+
+#undef TARGET_FUNCTION_ARG_PADDING
+#define TARGET_FUNCTION_ARG_PADDING m68k_function_arg_padding
+
 #undef  TARGET_HAVE_SPECULATION_SAFE_VALUE
 #define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed
 
@@ -370,6 +391,12 @@
     m68k_handle_fndecl_attribute, NULL },
   { "interrupt_thread", 0, 0, true,  false, false, false,
     m68k_handle_fndecl_attribute, NULL },
+  { "pascal", 0, 0, false, true, true, true,
+    m68k_handle_fndecl_attribute, NULL },
+  { "regparam", 1, 1, false, true, true, true,
+    m68k_handle_fndecl_attribute, NULL },
+  { "raw_inline", 1, 32, false, true, true, false,
+    m68k_handle_fndecl_attribute, NULL },
   { NULL, 0, 0, false, false, false, false, NULL, NULL }
 };
 
@@ -635,6 +662,8 @@
 	 clear how intentional that is.  */
       flag_no_function_cse = 1;
     }
+  else if(TARGET_PCREL)
+    m68k_symbolic_call_var = M68K_SYMBOLIC_CALL_BSRW_C;
 
   switch (m68k_symbolic_call_var)
     {
@@ -650,6 +679,10 @@
       m68k_symbolic_call = "bsr%.l %p0";
       break;
 
+    case M68K_SYMBOLIC_CALL_BSRW_C:
+      m68k_symbolic_call = "bsr%.w %c0";
+      break;
+
     case M68K_SYMBOLIC_CALL_NONE:
       gcc_assert (m68k_symbolic_call == NULL);
       break;
@@ -787,6 +820,9 @@
 			      int flags ATTRIBUTE_UNUSED,
 			      bool *no_add_attrs)
 {
+  if (TREE_CODE (*node) != FUNCTION_TYPE && TREE_CODE (*node) != TYPE_DECL)
+  {
+
   if (TREE_CODE (*node) != FUNCTION_DECL)
     {
       warning (OPT_Wattributes, "%qE attribute only applies to functions",
@@ -808,6 +844,9 @@
     }
 
   return NULL_TREE;
+  }
+  else
+  return NULL_TREE;
 }
 
 static void
@@ -906,7 +945,7 @@
 static bool
 m68k_save_reg (unsigned int regno, bool interrupt_handler)
 {
-  if (flag_pic && regno == PIC_REG)
+  if (!TARGET_SEP_DATA && flag_pic && regno == PIC_REG)
     {
       if (crtl->saves_all_registers)
 	return true;
@@ -1397,6 +1436,9 @@
   if (CALL_EXPR_STATIC_CHAIN (exp))
     return false;
 
+  if (decl && lookup_attribute ("raw_inline", TYPE_ATTRIBUTES( TREE_TYPE(decl) )))
+    return false;
+
   if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))
     {
       /* Check that the return value locations are the same.  For
@@ -1405,9 +1447,9 @@
       rtx cfun_value;
       rtx call_value;
 
-      cfun_value = FUNCTION_VALUE (TREE_TYPE (DECL_RESULT (cfun->decl)),
-				   cfun->decl);
-      call_value = FUNCTION_VALUE (TREE_TYPE (exp), decl);
+      cfun_value = m68k_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),
+				   cfun->decl, false);
+      call_value = m68k_function_value (TREE_TYPE (exp), decl, false);
 
       /* Check that the values are equal or that the result the callee
 	 function returns is superset of what the current function returns.  */
@@ -1431,11 +1473,106 @@
   return false;
 }
 
-/* On the m68k all args are always pushed.  */
+/* On the m68k all args are always pushed - NOT.  */
+
+void m68k_init_cumulative_args (CUMULATIVE_ARGS *cum,
+    const_tree fntype,
+    rtx libname ATTRIBUTE_UNUSED,
+    const_tree fndecl,
+    int n_named_args)
+{
+  cum->bytes = 0;
+  cum->index = 0;
+  cum->regparam = false;
+
+  if(!fntype)
+    return;
+
+  tree regparam = lookup_attribute ("regparam", TYPE_ATTRIBUTES( fntype ));
+  cum->regparam = regparam != NULL;
+  if(regparam)
+    {
+      regparam = TREE_VALUE(TREE_VALUE(regparam));
+      if(TREE_CODE(regparam) == STRING_CST)
+        {
+          const char *paramstr = TREE_STRING_POINTER(regparam);
+
+          const char *p = paramstr;
+
+          bool ok = true;
+          int idx = 0;
+          cum->arg_regs[0] = 0;
+          if(*p == '(')
+          {
+            idx = 1;
+            p++;
+          }
+          while(*p)
+            {
+              while(*p && (*p == '_' || *p == '%' || *p == ',' || *p == '(' || *p == ')' || *p == ' ' || *p == '\t'))
+                p++;
+
+              if(!*p)
+                break;
+
+              if(*p != 'a' && *p != 'd' && *p != 'A' && *p != 'D')
+                { ok = false; break; }
+              if(p[1] < '0' || p[1] > '7')
+                { ok = false; break; }
+              cum->arg_regs[idx++] = p[1] - '0'
+                + (*p == 'a' || *p == 'A' ? 8 : 0);
+
+              p += 2;
+
+            }
+          // TODO: error checking
+          cum->total_count = idx - 1;
+          if(cum->total_count < 0)
+            cum->total_count = 0;
+        }
+    }
+
+  if(!regparam && fndecl)
+    {
+      std::map< std::string, std::vector<int> >::iterator p
+        = pragma_parameter_directives.find(IDENTIFIER_POINTER(DECL_NAME(fndecl)));
+      if(p != pragma_parameter_directives.end())
+        {
+          cum->regparam = true;
+          cum->total_count = p->second.size()-1;
+          for(unsigned i = 0; i < p->second.size(); i++)
+            cum->arg_regs[i] = p->second[i];
+        }
+    }
+
+
+}
+
+int
+m68k_is_pascal_func(tree fntype, tree fndecl)
+{
+  if(!fntype)
+    return false;
+  if(lookup_attribute ("pascal", TYPE_ATTRIBUTES (fntype)))
+    {
+      CUMULATIVE_ARGS cum;
+      m68k_init_cumulative_args(&cum, fntype, NULL, fndecl, -1);
+      return !cum.regparam;
+    }
+  else
+    return false;
+}
 
 static rtx
-m68k_function_arg (cumulative_args_t, const function_arg_info &)
+m68k_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)
 {
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  if(!cum->regparam)
+    return NULL_RTX;
+
+  if(cum->index < cum->total_count)
+    return gen_rtx_REG (arg.mode, cum->arg_regs[cum->index+1]);
+  else
   return NULL_RTX;
 }
 
@@ -1445,9 +1582,11 @@
 {
   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
 
-  *cum += (arg.promoted_size_in_bytes () + 3) & ~3;
+  cum->bytes += (arg.type_size_in_bytes() + 1) & ~1;
+  cum->index ++;
 }
 
+
 /* Convert X to a legitimate function call memory reference and return the
    result.  */
 
@@ -1613,7 +1752,7 @@
 
 /* Called through CC_STATUS_INIT, which is invoked by final whenever a
    label is encountered.  */
-
+ 
 void
 m68k_init_cc ()
 {
@@ -3244,7 +3383,7 @@
 const char *
 output_move_himode (rtx *operands)
 {
-  if (GET_CODE (operands[1]) == CONST_INT)
+ if (GET_CODE (operands[1]) == CONST_INT)
     {
       if (operands[1] == const0_rtx
 	  && (DATA_REG_P (operands[0])
@@ -3277,7 +3416,7 @@
 
   /* 68k family always modifies the stack pointer by at least 2, even for
      byte pushes.  The 5200 (ColdFire) does not do this.  */
-
+  
   /* This case is generated by pushqi1 pattern now.  */
   gcc_assert (!(GET_CODE (operands[0]) == MEM
 		&& GET_CODE (XEXP (operands[0], 0)) == PRE_DEC
@@ -3315,7 +3454,7 @@
     {
       if (ADDRESS_REG_P (operands[1]))
 	CC_STATUS_INIT;
-      return "move%.w %1,%0";
+    return "move%.w %1,%0";
     }
   return "move%.b %1,%0";
 }
@@ -4363,24 +4502,24 @@
       return code;
     }
   else
-    {
+	{
       output_asm_insn ("sub%.l %R0,%R3\n\tsubx%.l %0,%3", ops);
       return swap_condition (code);
-    }
+	}
 }
 
 static void
 remember_compare_flags (rtx op0, rtx op1)
 {
   if (side_effects_p (op0) || side_effects_p (op1))
-    CC_STATUS_INIT;
+	CC_STATUS_INIT; 
   else
-    {
+	{
       flags_compare_op0 = op0;
       flags_compare_op1 = op1;
       flags_operand1 = flags_operand2 = NULL_RTX;
       flags_valid = FLAGS_VALID_SET;
-    }
+	}
 }
 
 /* Emit a comparison between OP0 and OP1.  CODE is the code of the
@@ -4468,11 +4607,11 @@
   else if (GET_CODE (op0) == MEM && GET_CODE (op1) == MEM)
     output_asm_insn ("cmpm%.b %1,%0", ops);
   else if (REG_P (op1) || (!REG_P (op0) && GET_CODE (op0) != MEM))
-    {
+	{
       output_asm_insn ("cmp%.b %d0,%d1", ops);
       std::swap (flags_compare_op0, flags_compare_op1);
       return swap_condition (code);
-    }
+	}
   else
     output_asm_insn ("cmp%.b %d1,%d0", ops);
   return code;
@@ -4504,14 +4643,14 @@
 	    output_asm_insn ("ftst%.d %0", ops);
 	  else
 	    output_asm_insn ("ftst%.x %0", ops);
-	}
-      else
+    }
+  else
 	output_asm_insn (("ftst%." + prec + " %0").c_str (), ops);
       return code;
     }
 
   switch (which_alternative)
-    {
+      {
     case 0:
       if (TARGET_COLDFIRE_FPU)
 	output_asm_insn ("fcmp%.d %1,%0", ops);
@@ -4520,7 +4659,7 @@
       break;
     case 1:
       output_asm_insn (("fcmp%." + prec + " %f1,%0").c_str (), ops);
-      break;
+	break;
     case 2:
       output_asm_insn (("fcmp%." + prec + " %0,%f1").c_str (), ops);
       std::swap (flags_compare_op0, flags_compare_op1);
@@ -4632,7 +4771,7 @@
       return "spl %0";
     case MINUS:
       return "smi %0";
-    default:
+      default:
       gcc_unreachable ();
     }
 }
@@ -4714,7 +4853,7 @@
       return "fjueq %l3";
     default:
       gcc_unreachable ();
-    }
+      }
 }
 
 /* Return an output template for a floating point scc
@@ -5552,6 +5691,42 @@
 const char *
 output_call (rtx x)
 {
+  if(GET_CODE (x) == SYMBOL_REF)
+    {
+      tree decl = SYMBOL_REF_DECL(x);
+      if(decl)
+        {
+          tree attr = lookup_attribute ("raw_inline", TYPE_ATTRIBUTES( TREE_TYPE(decl) ));
+          if(attr)
+            {
+              tree arg = TREE_VALUE(attr);
+
+              static char buf[512];
+              char *p = buf, *e = buf + sizeof(buf);
+              bool first = true;
+              p += snprintf(p, e-p, ".short ");
+
+              while(arg)
+                {
+                  tree word_tree = TREE_VALUE(arg);
+		  gcc_assert(TREE_CODE(word_tree) == INTEGER_CST);
+                  if (TREE_CODE(word_tree) == INTEGER_CST)
+                    {
+                      int word = TREE_INT_CST_LOW(word_tree);
+                      if(!first)
+                        p += snprintf(p, e-p, ", ");
+                      first = false;
+                      p += snprintf(p, e-p, "0x%04x", word);
+                    }
+                  arg = TREE_CHAIN(arg);
+                }
+
+                if(p < e)
+                  return buf;
+            }
+        }
+    }
+
   if (symbolic_operand (x, VOIDmode))
     return m68k_symbolic_call;
   else
@@ -5815,7 +5990,7 @@
    If there is need for a hard-float ABI it is probably worth doing it
    properly and also passing function arguments in FP registers.  */
 rtx
-m68k_libcall_value (machine_mode mode)
+m68k_libcall_value (enum machine_mode mode)
 {
   switch (mode) {
   case E_SFmode:
@@ -5835,11 +6010,27 @@
    NOTE: Due to differences in ABIs, don't call this function directly,
    use FUNCTION_VALUE instead.  */
 rtx
-m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)
+m68k_function_value (const_tree valtype, const_tree func_decl_or_type, bool outgoing)
 {
   machine_mode mode;
 
   mode = TYPE_MODE (valtype);
+
+  const_tree decl = NULL, type = NULL;
+  if(func_decl_or_type)
+    {
+      CUMULATIVE_ARGS cum;
+      decl = func_decl_or_type;
+      type = func_decl_or_type;
+      if(TREE_CODE(type) == FUNCTION_DECL)
+        type = TREE_TYPE(type);
+      else
+        decl = NULL;
+      m68k_init_cumulative_args(&cum, type, NULL, decl, -1);
+      if(cum.regparam)
+        return gen_rtx_REG (mode, cum.arg_regs[0]);
+    }
+
   switch (mode) {
   case E_SFmode:
   case E_DFmode:
@@ -5851,8 +6042,11 @@
     break;
   }
 
+#if 1 /* POINTERS_IN_D0 */
+  return gen_rtx_REG (mode, D0_REG);
+#else
   /* If the function returns a pointer, push that into %a0.  */
-  if (func && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (func))))
+  if (type && POINTER_TYPE_P (TREE_TYPE (type)) && !outgoing)
     /* For compatibility with the large body of existing code which
        does not always properly declare external functions returning
        pointer types, the m68k/SVR4 convention is to copy the value
@@ -5873,6 +6067,7 @@
     return gen_rtx_REG (mode, A0_REG);
   else
     return gen_rtx_REG (mode, D0_REG);
+#endif
 }
 
 /* Worker function for TARGET_RETURN_IN_MEMORY.  */
@@ -7045,6 +7240,8 @@
 static poly_int64
 m68k_return_pops_args (tree fundecl, tree funtype, poly_int64 size)
 {
+  if (lookup_attribute ("pascal", TYPE_ATTRIBUTES (funtype)))
+    return size;
   return ((TARGET_RTD
 	   && (!fundecl
 	       || TREE_CODE (fundecl) != IDENTIFIER_NODE)
@@ -7124,6 +7321,66 @@
   return FLT_EVAL_METHOD_UNPREDICTABLE;
 }
 
+extern int retro68_hack_asm_rts_counter;
+
+void
+m68k_write_macsbug_name(FILE *file, const char *name, tree decl)
+{
+  int len = strlen(name);
+  if(len > 255)
+    len = 255;
+
+  const char *section_name = DECL_SECTION_NAME (decl);
+  if(flag_function_sections && section_name)
+      fprintf(file, "\t.pushsection %s.macsbug,\"ax\",@progbits\n", section_name);
+  fprintf(file, "# macsbug symbol\n");
+  if(!retro68_hack_asm_rts_counter)
+    fprintf(file, "\trts\n");
+  if(len < 32)
+    fprintf(file, "\t.byte %d\n", len | 0x80);
+  else
+    fprintf(file, "\t.byte 0x80\n\t.byte %d\n", len);
+
+  ASM_OUTPUT_ASCII(file, name, len);
+  fprintf(file, "\t.align 2,0\n\t.short 0\n");
+  if(flag_function_sections && section_name)
+        fprintf(file, "\t.popsection\n", section_name);
+}
+
+static tree
+m68k_mangle_decl_assembler_name (tree decl, tree id)
+{
+  tree new_id = NULL_TREE;
+
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    {
+      tree attrs = TYPE_ATTRIBUTES ( TREE_TYPE(decl) );
+      if (attrs != NULL_TREE)
+        {
+          if (lookup_attribute ("pascal", attrs))
+            {
+              const char *old_str = IDENTIFIER_POINTER (id != NULL_TREE ? id : DECL_NAME (decl));
+              char *new_str, *p;
+              int len = strlen(old_str);
+              new_str = XALLOCAVEC (char, 1 + len);
+              for(int i = 0; i < len; i++)
+                new_str[i] = TOUPPER(old_str[i]);
+              new_str[len] = 0;
+
+              return get_identifier (new_str);
+            }
+        }
+    }
+
+  return id;
+}
+
+static pad_direction
+m68k_function_arg_padding (machine_mode mode, const_tree type)
+{
+  return PAD_UPWARD;
+}
+
 /* Implement PUSH_ROUNDING.  On the 680x0, sp@- in a byte insn really pushes
    a word.  On the ColdFire, sp@- in a byte insn pushes just a byte.  */
 
@@ -7151,4 +7408,20 @@
   return mode;
 }
 
+bool
+m68k_rawinline_p (rtx x)
+{
+  if(GET_CODE (x) == SYMBOL_REF)
+    {
+      tree decl = SYMBOL_REF_DECL(x);
+      if(decl)
+        {
+          tree attr = lookup_attribute ("raw_inline", TYPE_ATTRIBUTES( TREE_TYPE(decl) ));
+          if(attr)
+	    return true;
+	}
+    }
+  return false;
+}
+
 #include "gt-m68k.h"
diff -aurN gcc-12.2.0/gcc/config/m68k/m68kemb.h gcc-12.2.0-retro68/gcc/config/m68k/m68kemb.h
--- gcc-12.2.0/gcc/config/m68k/m68kemb.h	2022-08-19 15:09:52.656663444 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68kemb.h	2024-10-31 17:12:52.017002149 +0700
@@ -17,8 +17,6 @@
    and unions in registers, which is slightly more efficient.  */
 #define DEFAULT_PCC_STRUCT_RETURN 0
 
-#undef FUNCTION_VALUE
-#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))
 
 #undef LIBCALL_VALUE
 #define LIBCALL_VALUE(MODE)					\
diff -aurN gcc-12.2.0/gcc/config/m68k/m68k.h gcc-12.2.0-retro68/gcc/config/m68k/m68k.h
--- gcc-12.2.0/gcc/config/m68k/m68k.h	2022-08-19 15:09:52.652663394 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68k.h	2024-10-31 17:12:52.017002149 +0700
@@ -54,6 +54,7 @@
 
 #define SUBTARGET_EXTRA_SPECS
 
+
 /* Note that some other tm.h files include this one and then override
    many of the definitions that relate to assembler syntax.  */
 
@@ -193,9 +194,16 @@
 									\
       builtin_assert ("cpu=m68k");					\
       builtin_assert ("machine=m68k");					\
+      \
+      builtin_define("pascal=__attribute__((__pascal__))");	\
     }									\
   while (0)
 
+
+extern void m68k_register_pragmas(void);
+  /* Target Pragmas.  */
+#define REGISTER_TARGET_PRAGMAS() m68k_register_pragmas ()
+
 /* Classify the groups of pseudo-ops used to assemble QI, HI and SI
    quantities.  */
 #define INT_OP_STANDARD	0	/* .byte, .short, .long */
@@ -287,7 +295,7 @@
 
 #define UNITS_PER_WORD 4
 
-#define PARM_BOUNDARY (TARGET_SHORT ? 16 : 32)
+#define PARM_BOUNDARY 16 /* (TARGET_SHORT ? 16 : 32) */
 #define STACK_BOUNDARY 16
 #define FUNCTION_BOUNDARY 16
 #define EMPTY_FIELD_BOUNDARY 16
@@ -340,7 +348,7 @@
   0, 0, 0, 0, 0, 0, 0, 0,      \
                                \
   /* Address registers.  */    \
-  0, 0, 0, 0, 0, 0, 0, 1,      \
+  0, 0, 0, 0, 0, 1, 0, 1,      \
                                \
   /* Floating point registers  \
      (if available).  */       \
@@ -357,10 +365,10 @@
    Aside from that, you can include as many other registers as you like.  */
 #define CALL_USED_REGISTERS     \
  {/* Data registers.  */        \
-  1, 1, 0, 0, 0, 0, 0, 0,       \
+  1, 1, 1, 0, 0, 0, 0, 0,       \
                                 \
   /* Address registers.  */     \
-  1, 1, 0, 0, 0, 0, 0, 1,       \
+  1, 1, 0, 0, 0, 1, 0, 1,       \
                                 \
   /* Floating point registers   \
      (if available).  */        \
@@ -473,8 +481,7 @@
 #define FIRST_PARM_OFFSET(FNDECL) 8
 
 /* On the m68k the return value defaults to D0.  */
-#define FUNCTION_VALUE(VALTYPE, FUNC)  \
-  gen_rtx_REG (TYPE_MODE (VALTYPE), D0_REG)
+//  gen_rtx_REG (TYPE_MODE (VALTYPE), D0_REG)
 
 /* On the m68k the return value defaults to D0.  */
 #define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, D0_REG)
@@ -490,13 +497,21 @@
 /* On the m68k, all arguments are usually pushed on the stack.  */
 #define FUNCTION_ARG_REGNO_P(N) 0
 
-/* On the m68k, this is a single integer, which is a number of bytes
-   of arguments scanned so far.  */
-#define CUMULATIVE_ARGS int
+
+typedef struct {
+	int bytes; /* number of bytes  of arguments scanned so far.  */
+	int total_count;
+	int index;
+	int regparam;
+    int arg_regs[32];
+    
+} CUMULATIVE_ARGS;
+
+extern void m68k_init_cumulative_args (CUMULATIVE_ARGS *cum, const_tree fntype, rtx libname, const_tree fundecl, int n_named_args);
 
 /* On the m68k, the offset starts at 0.  */
 #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
- ((CUM) = 0)
+  m68k_init_cumulative_args(&(CUM), (FNTYPE), (LIBNAME), (INDIRECT), (N_NAMED_ARGS));
 
 #define FUNCTION_PROFILER(FILE, LABELNO)  \
   asm_fprintf (FILE, "\tlea %LLP%d,%Ra0\n\tjsr mcount\n", (LABELNO))
@@ -898,7 +913,8 @@
 extern const char *m68k_symbolic_jump;
 
 enum M68K_SYMBOLIC_CALL { M68K_SYMBOLIC_CALL_NONE, M68K_SYMBOLIC_CALL_JSR,
-			  M68K_SYMBOLIC_CALL_BSR_C, M68K_SYMBOLIC_CALL_BSR_P };
+			  M68K_SYMBOLIC_CALL_BSR_C, M68K_SYMBOLIC_CALL_BSR_P,
+			  M68K_SYMBOLIC_CALL_BSRW_C };
 
 extern enum M68K_SYMBOLIC_CALL m68k_symbolic_call_var;
 
@@ -917,3 +933,15 @@
 extern int m68k_sched_indexed_address_bypass_p (rtx_insn *, rtx_insn *);
 
 #define CPU_UNITS_QUERY 1
+
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)		\
+  do								\
+    {								\
+      if (!flag_inhibit_size_directive)				\
+	ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);			\
+      m68k_write_macsbug_name(FILE, FNAME, DECL);			\
+    }								\
+  while (0)
+
+extern int m68k_is_pascal_func(tree, tree);
+#define IS_PASCAL_FUNC(fntype, fndecl) m68k_is_pascal_func(fntype, fndecl)
--- gcc-12.2.0/gcc/config/m68k/m68k-macos.h	1970-01-01 07:00:00.000000000 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68k-macos.h	2024-10-31 18:26:41.264519758 +0700
@@ -0,0 +1,26 @@
+
+#define LIBGCC_SPEC "--start-group -lretrocrt -lgcc -lInterface --end-group "
+#define LINK_SPEC "-elf2mac -q -undefined=_consolewrite"
+
+#undef  LIB_SPEC
+#define LIB_SPEC "--start-group -lc -lretrocrt -lInterface --end-group"
+
+#define LINK_GCC_C_SEQUENCE_SPEC "--start-group -lgcc -lc -lretrocrt -lInterface --end-group"
+
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC ""
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC ""
+
+#undef CPP_SPEC
+#define CPP_SPEC "-Wno-trigraphs"
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()          \
+  do                                      \
+    {                                     \
+      builtin_define ("macintosh");       \
+      builtin_define ("Macintosh");       \
+    }                                     \
+  while (0)
--- gcc-12.2.0/gcc/config/m68k/m68k-mac-pragmas.c	1970-01-01 07:00:00.000000000 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68k-mac-pragmas.c	2024-10-31 18:26:41.257853007 +0700
@@ -0,0 +1,118 @@
+#include <string>
+#include <map>
+#include <vector>
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "hash-set.h"
+#include "vec.h"
+#include "double-int.h"
+#include "input.h"
+#include "alias.h"
+#include "symtab.h"
+#include "inchash.h"
+#include "tree.h"
+
+#include "c-family/c-pragma.h"
+#include "c-family/c-common.h"
+#include "diagnostic-core.h"
+#include "cpplib.h"
+
+std::map<std::string, int> pragma_parameter_register_names;
+extern std::map< std::string, std::vector<int> > pragma_parameter_directives;
+
+
+static int lookup_reg(std::string s)
+{
+  std::map<std::string, int>::const_iterator p = pragma_parameter_register_names.find(s);
+  if(p == pragma_parameter_register_names.end())
+    return -1;
+  return p->second;
+}
+
+static void
+m68k_pragma_parameter (cpp_reader * reader ATTRIBUTE_UNUSED)
+{
+  /* on off */
+  tree token;
+  enum cpp_ttype type;
+
+  std::string name;
+  std::vector<int> argregs;
+
+  type = pragma_lex (&token);
+  argregs.push_back(0);
+  if (type == CPP_NAME)
+    {
+      name = IDENTIFIER_POINTER(token);
+      type = pragma_lex (&token);
+      if (type == CPP_NAME)
+        {
+          argregs.back() = lookup_reg(name);
+          if(argregs.back() < 0)
+            {
+              error ("invalid register name %s", name.c_str());
+              return;
+            }
+          name = IDENTIFIER_POINTER(token);
+          type = pragma_lex (&token);
+        }
+      if (type == CPP_EOF)
+        {
+          pragma_parameter_directives[name] = argregs;
+          return;
+        }
+
+      if (type == CPP_OPEN_PAREN)
+        {
+          type = pragma_lex (&token);
+          while(argregs.size() == 1 ? type == CPP_NAME : type == CPP_COMMA)
+            {
+              if(argregs.size() != 1)
+                type = pragma_lex (&token);
+              if(type != CPP_NAME)
+                break;
+              
+              argregs.push_back(lookup_reg(IDENTIFIER_POINTER(token)));
+              if(argregs.back() < 0)
+                {
+                  error ("invalid register name %s", IDENTIFIER_POINTER(token));
+                  return;
+                }
+
+              type = pragma_lex (&token);
+            }
+
+          if (type == CPP_CLOSE_PAREN)
+            {
+              type = pragma_lex (&token);
+              if (type != CPP_EOF)
+                {
+                  error ("junk at end of #pragma parameter");
+                }
+              else
+                {
+                  pragma_parameter_directives[name] = argregs;
+                }
+              return;
+            }
+        }
+    }
+  error ("malformed #pragma parameter ");
+}
+
+
+void
+m68k_register_pragmas()
+{
+  for(int i = 0; i < 8; i++)
+    {
+      std::string n(1, '0' + i);
+      pragma_parameter_register_names["__D" + n] = i;
+      pragma_parameter_register_names["__A" + n] = i + 8;
+    }
+  c_register_pragma (NULL, "parameter", m68k_pragma_parameter);
+
+}
diff -aurN gcc-12.2.0/gcc/config/m68k/m68k.md gcc-12.2.0-retro68/gcc/config/m68k/m68k.md
--- gcc-12.2.0/gcc/config/m68k/m68k.md	2022-08-19 15:09:52.656663444 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68k.md	2024-10-31 17:12:52.017002149 +0700
@@ -1165,12 +1165,26 @@
    move%.b %1,%0"
   [(set_attr "type" "clr,clr,move,move")])
 
-(define_expand "pushqi1"
-  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -2)))
-   (set (mem:QI (plus:SI (reg:SI SP_REG) (const_int 1)))
-	(match_operand:QI 0 "general_operand" ""))]
+; (define_expand "pushqi1"
+;  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -2)))
+;   (set (mem:QI (reg:SI SP_REG) )
+;	(match_operand:QI 0 "general_operand" ""))]
+;  "!TARGET_COLDFIRE"
+;  "")
+
+; (define_insn "*pushqi1"
+;  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -2)))
+;   (set (mem:QI (reg:SI SP_REG) )
+;	(match_operand:QI 0 "general_operand" ""))]
+;  "!TARGET_COLDFIRE"
+;  { return "move%.b %0,%-"; })
+
+(define_insn "*pushqi1"
+  [
+   (set (mem:QI (pre_modify:SI (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -2))))
+	(match_operand:QI 0 "general_operand" "dmn"))]
   "!TARGET_COLDFIRE"
-  "")
+  { return "move%.b %0,%-"; })
 
 (define_expand "reload_insf"
   [(set (match_operand:SF 0 "nonimmediate_operand" "=f")
@@ -6017,6 +6031,41 @@
   operands[1] = m68k_legitimize_call_address (operands[1]);
 })
 
+(define_expand "call_pop"
+  [(parallel [(call (match_operand:QI 0 "memory_operand" "")
+		    (match_operand:SI 1 "general_operand" ""))
+	      (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 3 "" "")))])]
+  ""
+{
+  operands[0] = m68k_legitimize_call_address (operands[0]);
+})
+(define_expand "call_value_pop"
+  [(parallel [(set (match_operand 0 "" "")
+                   (call (match_operand:QI 1 "memory_operand" "")
+		         (match_operand:SI 2 "general_operand" "")))
+	      (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 4 "" "")))])]
+  ""
+{
+  operands[1] = m68k_legitimize_call_address (operands[1]);
+})
+
+(define_insn "*call_pop"
+  [(call (mem:QI (match_operand:SI 0 "call_operand" "a,W"))
+	 (match_operand:SI 1 "general_operand" "g,g"))
+         (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 2 "" "")))]
+  ;; Operand 1 not really used on the m68000.
+  "!SIBLING_CALL_P (insn)"
+{
+  return output_call (operands[0]);
+}
+  [(set_attr "type" "jsr")])
+
 (define_insn "*non_symbolic_call_value"
   [(set (match_operand 0 "" "=rf,rf")
 	(call (mem:QI (match_operand:SI 1 "non_symbolic_call_operand" "a,W"))
@@ -6035,7 +6084,7 @@
   "!SIBLING_CALL_P (insn) && m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_JSR"
 {
   operands[0] = operands[1];
-  return m68k_symbolic_call;
+  return output_call (operands[0]);
 }
   [(set_attr "type" "jsr")
    (set_attr "opx" "1")])
@@ -6047,14 +6096,66 @@
   ;; Operand 2 not really used on the m68000.
   "!SIBLING_CALL_P (insn)
    && (m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSR_C
-       || m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSR_P)"
+       || m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSR_P
+       || m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSRW_C)"
 {
   operands[0] = operands[1];
-  return m68k_symbolic_call;
+  return output_call (operands[0]);
 }
   [(set_attr "type" "bsr")
    (set_attr "opx" "1")])
 
+
+(define_insn "*non_symbolic_call_value_pop"
+  [(set (match_operand 0 "" "=rf,rf")
+	(call (mem:QI (match_operand:SI 1 "non_symbolic_call_operand" "a,W"))
+	      (match_operand:SI 2 "general_operand" "g,g")))
+   (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 3 "" "")))]
+  ;; Operand 2 not really used on the m68000.
+  "!SIBLING_CALL_P (insn)"
+  "jsr %a1"
+  [(set_attr "type" "jsr")
+   (set_attr "opx" "1")])
+
+(define_insn "*symbolic_call_value_pop_jsr"
+  [(set (match_operand 0 "" "=rf,rf")
+	(call (mem:QI (match_operand:SI 1 "symbolic_operand" "a,W"))
+	      (match_operand:SI 2 "general_operand" "g,g")))
+   (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 3 "" "")))]
+  ;; Operand 2 not really used on the m68000.
+  "!SIBLING_CALL_P (insn) && m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_JSR"
+{
+  operands[0] = operands[1];
+  return output_call (operands[0]);
+}
+  [(set_attr "type" "jsr")
+   (set_attr "opx" "1")])
+
+(define_insn "*symbolic_call_value_pop_bsr"
+  [(set (match_operand 0 "" "=rf,rf")
+	(call (mem:QI (match_operand:SI 1 "symbolic_operand" "a,W"))
+	      (match_operand:SI 2 "general_operand" "g,g")))
+   (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (match_operand:SI 3 "" "")))]
+  ;; Operand 2 not really used on the m68000.
+  "!SIBLING_CALL_P (insn)
+   && (m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSR_C
+       || m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSR_P
+       || m68k_symbolic_call_var == M68K_SYMBOLIC_CALL_BSRW_C)"
+{
+  operands[0] = operands[1];
+  return output_call (operands[0]);
+}
+  [(set_attr "type" "bsr")
+   (set_attr "opx" "1")])
+
+
+
 ;; Call subroutine returning any type.
 
 (define_expand "untyped_call"
@@ -6133,6 +6234,7 @@
   [(return)]
   ""
 {
+  extern int retro68_hack_asm_rts_counter;
   switch (m68k_get_function_kind (current_function_decl))
     {
     case m68k_fk_interrupt_handler:
@@ -6142,11 +6244,17 @@
       return "sleep";
 
     default:
+      retro68_hack_asm_rts_counter = 2;
       if (crtl->args.pops_args)
 	{
 	  operands[0] = GEN_INT (crtl->args.pops_args);
-	  return "rtd %0";
-	}
+          if (TARGET_68020)
+            return "rtd %0";
+          else
+            return "move.l (%%a7)+, %%a0\n"
+                 "\tlea %a0(%%a7), %%a7\n"
+                 "\tjmp (%%a0)";
+  	}
       else
 	return "rts";
     }
--- gcc-12.2.0/gcc/config/m68k/m68k-passes.def	1970-01-01 07:00:00.000000000 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68k-passes.def	2024-10-31 18:26:41.257853007 +0700
@@ -0,0 +1,22 @@
+
+/*
+   Macros that can be used in this file:
+   INSERT_PASS_AFTER (PASS, INSTANCE, TGT_PASS)
+   INSERT_PASS_BEFORE (PASS, INSTANCE, TGT_PASS)
+   REPLACE_PASS (PASS, INSTANCE, TGT_PASS)
+ */
+
+	// insert a stack adjustments (csa) pass early in compilation,
+	// before register allocation.
+	// This allows removing some extraneous moves in connection with pascal functions:
+	// pascal short bar(); pascal void foo(short);
+	// foo(bar());
+	// 
+	// subq #2, sp
+	// jsr bar
+	// move (sp), d0	; <-- otherwise we end up with these two useless instructions
+	// move d0, (sp)	; <-- which are not removed if the register is already allocated
+	//			; <-- when csa figures out that no actual push or pop is needed
+	// jsr foo
+
+INSERT_PASS_AFTER (pass_combine, 1, pass_stack_adjustments);
diff -aurN gcc-12.2.0/gcc/config/m68k/m68k-protos.h gcc-12.2.0-retro68/gcc/config/m68k/m68k-protos.h
--- gcc-12.2.0/gcc/config/m68k/m68k-protos.h	2022-08-19 15:09:52.652663394 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/m68k-protos.h	2024-10-31 17:12:52.017002149 +0700
@@ -79,7 +79,7 @@
 extern bool m68k_tls_reference_p (rtx, bool);
 extern int valid_dbcc_comparison_p_2 (rtx, machine_mode);
 extern rtx m68k_libcall_value (machine_mode);
-extern rtx m68k_function_value (const_tree, const_tree);
+extern rtx m68k_function_value (const_tree, const_tree, bool);
 extern int emit_move_sequence (rtx *, machine_mode, rtx);
 extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);
 extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);
@@ -113,4 +113,8 @@
 extern rtx m68k_legitimize_call_address (rtx);
 extern rtx m68k_legitimize_sibcall_address (rtx);
 extern int m68k_hard_regno_rename_ok(unsigned int, unsigned int);
+
+extern void m68k_write_macsbug_name(FILE *, const char *, tree decl);
 extern poly_int64 m68k_push_rounding (poly_int64);
+
+extern bool m68k_rawinline_p (rtx x);
diff -aurN gcc-12.2.0/gcc/config/m68k/predicates.md gcc-12.2.0-retro68/gcc/config/m68k/predicates.md
--- gcc-12.2.0/gcc/config/m68k/predicates.md	2022-08-19 15:09:52.656663444 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/predicates.md	2024-10-31 17:12:52.043669077 +0700
@@ -156,9 +156,18 @@
     }
 })
 
+
+(define_predicate "rawinline_operand"
+  (match_code "symbol_ref")
+{
+  return m68k_rawinline_p(op);
+})
+
+
 ;; A constant that can be used the address in a call insn
 (define_predicate "const_call_operand"
   (ior (match_operand 0 "const_int_operand")
+       (match_operand 0 "rawinline_operand")
        (and (match_test "m68k_symbolic_call != NULL")
 	    (match_operand 0 "symbolic_operand"))))
 
diff -aurN gcc-12.2.0/gcc/config/m68k/t-m68k gcc-12.2.0-retro68/gcc/config/m68k/t-m68k
--- gcc-12.2.0/gcc/config/m68k/t-m68k	2022-08-19 15:09:52.656663444 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/t-m68k	2024-10-31 17:12:52.043669077 +0700
@@ -2,3 +2,7 @@
 
 M68K_MLIB_CPU += && (CPU !~ "^mcf")
 M68K_ARCH := m68k
+
+M68K_MLIB_CPU += && (CPU !~ "^m68060") && (CPU !~ "^cpu32") && (CPU !~ "^fidoa")
+
+PASSES_EXTRA += $(srcdir)/config/m68k/m68k-passes.def
--- gcc-12.2.0/gcc/config/m68k/t-macos	1970-01-01 07:00:00.000000000 +0700
+++ gcc-12.2.0-retro68/gcc/config/m68k/t-macos	2024-10-31 18:26:41.264519758 +0700
@@ -0,0 +1,5 @@
+m68k-mac-pragmas.o: $(srcdir)/config/m68k/m68k-mac-pragmas.c
+	  $(COMPILE) $<
+	  $(POSTCOMPILE)
+
+M68K_MLIB_CPU += && (CPU !~ "^m68060") && (CPU !~ "^cpu32") && (CPU !~ "^fidoa")
--- gcc-12.2.0/gcc/config/rs6000/macos.h	1970-01-01 07:00:00.000000000 +0700
+++ gcc-12.2.0-retro68/gcc/config/rs6000/macos.h	2024-10-31 18:26:41.384521270 +0700
@@ -0,0 +1,320 @@
+/* Definitions of target machine for GNU compiler,
+   for IBM RS/6000 POWER running AIX.
+   Copyright (C) 2000-2015 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Yes!  We are AIX!  */
+#define DEFAULT_ABI ABI_AIX
+#undef  TARGET_AIX
+#define TARGET_AIX 1
+
+/* Linux64.h wants to redefine TARGET_AIX based on -m64, but it can't be used
+   in the #if conditional in options-default.h, so provide another macro.  */
+#undef  TARGET_AIX_OS
+#define TARGET_AIX_OS 1
+
+/* AIX always has a TOC.  */
+#define TARGET_NO_TOC 0
+#define TARGET_HAS_TOC 1
+#define FIXED_R2 1
+
+
+/* AIX allows r13 to be used in 32-bit mode.  */
+#define FIXED_R13 0
+
+/* 32-bit and 64-bit AIX stack boundary is 128.  */
+#undef  STACK_BOUNDARY
+#define STACK_BOUNDARY 128
+
+#undef  TARGET_IEEEQUAD
+#define TARGET_IEEEQUAD 0
+
+
+#if HAVE_AS_REF
+/* Issue assembly directives that create a reference to the given DWARF table
+   identifier label from the current function section.  This is defined to
+   ensure we drag frame frame tables associated with needed function bodies in
+   a link with garbage collection activated.  */
+#define ASM_OUTPUT_DWARF_TABLE_REF rs6000_aix_asm_output_dwarf_table_ref
+#endif
+
+/* This is the only version of nm that collect2 can work with.  */
+//#define REAL_NM_FILE_NAME "/usr/ucb/nm"
+
+#define USER_LABEL_PREFIX  ""
+
+/* Don't turn -B into -L if the argument specifies a relative file name.  */
+#define RELATIVE_PREFIX_NOT_LINKDIR
+
+/* Because of the above, we must have gcc search itself to find libgcc.a.  */
+#define LINK_LIBGCC_SPECIAL_1
+
+#undef ASM_DEFAULT_SPEC
+#define ASM_DEFAULT_SPEC ""
+
+
+/* Static linking with shared libstdc++ requires libsupc++ as well.  */
+#define LIBSTDCXX_STATIC "supc++"
+
+/* Compute field alignment.
+   This implements the 'power' alignment rule by pegging the alignment of
+   items (beyond the first aggregate field) to 32 bits.  The pegging is
+   suppressed for vector and long double items (both 128 in size).
+   There is a dummy use of the FIELD argument to avoid an unused variable
+   warning (see PR59496).  */
+#define ADJUST_FIELD_ALIGN(FIELD, TYPE, COMPUTED)		\
+  ((void) (FIELD),						\
+    (TARGET_ALIGN_NATURAL					\
+     ? (COMPUTED)						\
+     : (COMPUTED) == 128					\
+	? 128							\
+	: MIN ((COMPUTED), 32)))
+
+/* AIX increases natural record alignment to doubleword if the first
+   field is an FP double while the FP fields remain word aligned.  */
+#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED)			\
+  ((TREE_CODE (STRUCT) == RECORD_TYPE					\
+    || TREE_CODE (STRUCT) == UNION_TYPE					\
+    || TREE_CODE (STRUCT) == QUAL_UNION_TYPE)				\
+   && TARGET_ALIGN_NATURAL == 0						\
+   ? rs6000_special_round_type_align (STRUCT, COMPUTED, SPECIFIED)	\
+   : MAX ((COMPUTED), (SPECIFIED)))
+
+/* The AIX ABI isn't explicit on whether aggregates smaller than a
+   word/doubleword should be padded upward or downward.  One could
+   reasonably assume that they follow the normal rules for structure
+   layout treating the parameter area as any other block of memory,
+   then map the reg param area to registers, i.e., pad upward, which
+   is the way IBM Compilers for AIX behave.
+   Setting both of the following defines results in this behavior.  */
+#define AGGREGATE_PADDING_FIXED 1
+#define AGGREGATES_PAD_UPWARD_ALWAYS 1
+
+/* Specify padding for the last element of a block move between
+   registers and memory.  FIRST is nonzero if this is the only
+   element.  */
+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \
+  (!(FIRST) ? PAD_UPWARD : targetm.calls.function_arg_padding (MODE, TYPE))
+
+
+/* Indicate that jump tables go in the text section.  */
+
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
+
+#define PROFILE_HOOK(LABEL)   output_profile_hook (LABEL)
+
+/* No version of AIX fully supports AltiVec or 64-bit instructions in
+   32-bit mode.  */
+#define OS_MISSING_POWERPC64 1
+#define OS_MISSING_ALTIVEC 1
+
+/* WINT_TYPE */
+#define WINT_TYPE "int"
+
+/* Static stack checking is supported by means of probes.  */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+/* Use standard DWARF numbering for DWARF debugging information.  */
+#define RS6000_USE_DWARF_NUMBERING
+
+
+
+/* MacOS does support Altivec.  */
+#/*undef  TARGET_ALTIVEC
+#define TARGET_ALTIVEC 1
+#undef  TARGET_ALTIVEC_ABI
+#define TARGET_ALTIVEC_ABI 1
+#undef  TARGET_ALTIVEC_VRSAVE
+#define TARGET_ALTIVEC_VRSAVE 1*/
+
+#undef TARGET_OS_CPP_BUILTINS
+/* __POWERPC__ must be defined for some header files */
+#define TARGET_OS_CPP_BUILTINS()          \
+  do                                      \
+    {                                     \
+      builtin_define ("__ppc__");               \
+      builtin_define ("__PPC__");               \
+      builtin_define ("__POWERPC__");           \
+      builtin_define ("__NATURAL_ALIGNMENT__"); \
+      builtin_define ("macintosh");             \
+      builtin_define ("Macintosh");             \
+      builtin_assert ("system=macos");     \
+      builtin_assert ("cpu=powerpc");     \
+      builtin_assert ("machine=powerpc"); \
+            builtin_assert ("cpu=m68k");          \
+      builtin_assert ("machine=m68k");          \
+      builtin_define("pascal=__attribute__((__pascal__))");	\
+      builtin_define("__IEEE_BIG_ENDIAN"); \
+    }                                     \
+  while (0)
+
+/* --no-check-sections  :   sections overlap on purpose!
+   -undefined=_consolewrite : hack to allow easy configuration of console output             
+*/
+
+#define LINK_SPEC "%{!r:-btextro} -bhalt:4 -bnodelcsect \
+--no-check-sections -undefined=_consolewrite \
+%{shared:-bM:SRE}"
+
+#define LIB_SPEC "-lc"
+#define LIBGCC_SPEC "-lgcc %{carbon: -lretrocrt-carbon} %{!carbon: -lretrocrt} -lgcc %{carbon: -lCarbonLib} %{!carbon: -lInterfaceLib}"
+
+#define LINK_GCC_C_SEQUENCE_SPEC "--start-group -lgcc -lc %{carbon: -lretrocrt-carbon} %{!carbon: -lretrocrt} %{carbon: -lCarbonLib} %{!carbon: -lInterfaceLib} --end-group"
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC ""
+
+#undef CPP_SPEC
+#define CPP_SPEC "-Wno-trigraphs"
+
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT 0
+// (MASK_POWERPC | MASK_MULTIPLE | MASK_NEW_MNEMONICS)
+
+#undef PROCESSOR_DEFAULT
+#define PROCESSOR_DEFAULT PROCESSOR_PPC601
+
+#undef OS_MISSING_ALTIVEC
+#define OS_MISSING_ALTIVEC 0
+
+#undef VECTOR_SAVE_INLINE
+#define VECTOR_SAVE_INLINE(FIRST_REG) 1
+
+
+#define TARGET_USES_AIX64_OPT
+
+#undef TARGET_POINTERS_TO_NESTED_FUNCTIONS
+#define TARGET_POINTERS_TO_NESTED_FUNCTIONS 0
+
+/* Type used for ptrdiff_t, as a string used in a declaration.  */
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "long int"
+
+/* The AIX linker will discard static constructors in object files before
+   collect has a chance to see them, so collect2 contains functionality
+   to scan the object files directly, enabled by:
+	#define COLLECT_EXPORT_LIST
+   
+   However, this seems to find all constructors and exception frame tables,
+   and thus leads to huge executables.
+   As we don't need to be compatible with the AIX linker, binutils had been
+   made to not discard these symbols any more *if* the corresponding object
+   file is loaded.
+*/
+
+/* Select a format to encode pointers in exception handling data.  CODE
+   is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is
+   true if the symbol may be affected by dynamic relocations.  */
+#undef	ASM_PREFERRED_EH_DATA_FORMAT
+#define	ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  (DW_EH_PE_absptr)
+#undef EH_TABLES_CAN_BE_READ_ONLY
+#define EH_TABLES_CAN_BE_READ_ONLY 0
+
+#if 0
+/* On AIX, initialisers specified with -binitfini are called in breadth-first
+   order.
+   e.g. if a.out depends on lib1.so, the init function for a.out is called before
+   the init function for lib1.so.
+
+   To ensure global C++ constructors in linked libraries are run before global
+   C++ constructors from the current module, there is additional symbol scanning
+   logic in collect2.
+
+   The global initialiser/finaliser functions are named __GLOBAL_AIXI_{libname}
+   and __GLOBAL_AIXD_{libname} and are exported from each shared library.
+
+   collect2 will detect these symbols when they exist in shared libraries that
+   the current program is being linked against.  All such initiliser functions
+   will be called prior to the constructors of the current program, and
+   finaliser functions called after destructors.
+
+   Reference counting generated by collect2 will ensure that constructors are
+   only invoked once in the case of multiple dependencies on a library.
+
+   -binitfini is still used in parallel to this solution.
+   This handles the case where a library is loaded through dlopen(), and also
+   handles the option -blazy.
+*/
+#define COLLECT_SHARED_INIT_FUNC(STREAM, FUNC) \
+	  fprintf ((STREAM), "void %s() {\n\t%s();\n}\n", aix_shared_initname, (FUNC))
+#define COLLECT_SHARED_FINI_FUNC(STREAM, FUNC) \
+	  fprintf ((STREAM), "void %s() {\n\t%s();\n}\n", aix_shared_fininame, (FUNC))
+
+#endif
+
+#if HAVE_AS_REF
+/* Issue assembly directives that create a reference to the given DWARF table
+   identifier label from the current function section.  This is defined to
+   ensure we drag frame tables associated with needed function bodies in
+   a link with garbage collection activated.  */
+#define ASM_OUTPUT_DWARF_TABLE_REF rs6000_aix_asm_output_dwarf_table_ref
+#endif
+/* Use standard DWARF numbering for DWARF debugging information.  */
+#define RS6000_USE_DWARF_NUMBERING
+#define DWARF2_DEBUGGING_INFO 1
+//#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+#define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG
+#define DEBUG_INFO_SECTION	"0x10000"
+#define DEBUG_LINE_SECTION	"0x20000"
+#define DEBUG_PUBNAMES_SECTION	"0x30000"
+#define DEBUG_PUBTYPES_SECTION	"0x40000"
+#define DEBUG_ARANGES_SECTION	"0x50000"
+#define DEBUG_ABBREV_SECTION	"0x60000"
+#define DEBUG_STR_SECTION	"0x70000"
+#define DEBUG_RANGES_SECTION	"0x80000"
+#define DEBUG_LOC_SECTION	"0x90000"
+#define DEBUG_FRAME_SECTION	"0xA0000"
+#define DEBUG_MACINFO_SECTION	"0xB0000"
+#define DEBUG_MACRO_SECTION	"0xB0000"
+
+
+
+#define SIG_ATOMIC_TYPE "int"
+
+#define INT8_TYPE "signed char"
+#define INT16_TYPE "short int"
+#define INT32_TYPE "long int"
+#define INT64_TYPE "long long int"
+#define UINT8_TYPE "unsigned char"
+#define UINT16_TYPE "short unsigned int"
+#define UINT32_TYPE "long unsigned int"
+#define UINT64_TYPE "long long unsigned int"
+
+#define INT_LEAST8_TYPE "signed char"
+#define INT_LEAST16_TYPE "short int"
+#define INT_LEAST32_TYPE "long int"
+#define INT_LEAST64_TYPE "long long int"
+#define UINT_LEAST8_TYPE "unsigned char"
+#define UINT_LEAST16_TYPE "short unsigned int"
+#define UINT_LEAST32_TYPE "long unsigned int"
+#define UINT_LEAST64_TYPE "long long unsigned int"
+
+#define INT_FAST8_TYPE "signed char"
+#define INT_FAST16_TYPE "short int"
+#define INT_FAST32_TYPE "long int"
+#define INT_FAST64_TYPE "long long int"
+#define UINT_FAST8_TYPE "unsigned char"
+#define UINT_FAST16_TYPE "short unsigned int"
+#define UINT_FAST32_TYPE "long unsigned int"
+#define UINT_FAST64_TYPE "long long unsigned int"
+
+#define INTPTR_TYPE "long int"
+#define UINTPTR_TYPE "long unsigned int"
+
diff -aurN gcc-12.2.0/gcc/config/rs6000/rs6000.cc gcc-12.2.0-retro68/gcc/config/rs6000/rs6000.cc
--- gcc-12.2.0/gcc/config/rs6000/rs6000.cc	2022-08-19 15:09:52.700664008 +0700
+++ gcc-12.2.0-retro68/gcc/config/rs6000/rs6000.cc	2024-10-31 17:12:52.143670055 +0700
@@ -1273,6 +1273,9 @@
     rs6000_handle_struct_attribute, NULL },
   { "gcc_struct", 0, 0, false, false, false, false,
     rs6000_handle_struct_attribute, NULL },
+  { "pascal", 0, 0, false, true, true, false/*don't be strict about function pointers*/,
+    NULL, NULL },
+
 #ifdef SUBTARGET_ATTRIBUTE_TABLE
   SUBTARGET_ATTRIBUTE_TABLE,
 #endif
@@ -21624,8 +21627,9 @@
 {
   struct declare_alias_data data = {file, false};
   ASM_OUTPUT_LABEL (file, name);
-  symtab_node::get_create (decl)->call_for_symbol_and_aliases (rs6000_declare_alias,
-							       &data, true);
+  if (symtab_node::get (decl))
+    symtab_node::get (decl)->call_for_symbol_and_aliases (rs6000_declare_alias,
+							  &data, true);
 }
 
 /* Overide the default 'SYMBOL-.' syntax with AIX compatible 'SYMBOL-$'. */
diff -aurN gcc-12.2.0/gcc/config/rs6000/rs6000.opt gcc-12.2.0-retro68/gcc/config/rs6000/rs6000.opt
--- gcc-12.2.0/gcc/config/rs6000/rs6000.opt	2022-08-19 15:09:52.700664008 +0700
+++ gcc-12.2.0-retro68/gcc/config/rs6000/rs6000.opt	2024-10-31 17:12:52.143670055 +0700
@@ -577,6 +577,9 @@
 TargetVariable
 long rs6000_stack_protector_guard_offset = 0
 
+carbon
+Target RejectNegative
+
 ;; -mno-speculate-indirect-jumps adds deliberate misprediction to indirect
 ;; branches via the CTR.
 mspeculate-indirect-jumps
--- gcc-12.2.0/gcc/config/rs6000/t-macos	1970-01-01 07:00:00.000000000 +0700
+++ gcc-12.2.0-retro68/gcc/config/rs6000/t-macos	2024-10-31 18:26:41.377854519 +0700
@@ -0,0 +1,35 @@
+# Copyright (C) 1998-2015 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Build the libraries for pthread and all of the 
+# different processor models
+
+#MULTILIB_OPTIONS	=
+# mcpu=powerpc
+
+#MULTILIB_DIRNAMES	= 
+#powerpc
+
+#MULTILIB_MATCHES	= 
+#			  mcpu?powerpc=mcpu?powerpc \
+#			  mcpu?powerpc=mcpu?601 \
+#			  mcpu?powerpc=mcpu?602 \
+#			  mcpu?powerpc=mcpu?603 \
+#			  mcpu?powerpc=mcpu?603e \
+#			  mcpu?powerpc=mcpu?604 \
+#			  mcpu?powerpc=mcpu?604e
diff -aurN gcc-12.2.0/gcc/config.gcc gcc-12.2.0-retro68/gcc/config.gcc
--- gcc-12.2.0/gcc/config.gcc	2022-08-19 15:09:52.552662114 +0700
+++ gcc-12.2.0-retro68/gcc/config.gcc	2024-10-31 17:12:51.726999313 +0700
@@ -442,6 +442,8 @@
 m68k-*-*)
 	extra_headers=math-68881.h
 	extra_options="${extra_options} m68k/m68k-tables.opt"
+	c_target_objs="m68k-mac-pragmas.o"
+	cxx_target_objs="m68k-mac-pragmas.o"
 	;;
 microblaze*-*-*)
         cpu_type=microblaze
@@ -2355,6 +2357,23 @@
 		;;
 	esac
 	;;
+m68k-*-macos*)
+	default_m68k_cpu=68020
+	default_cf_cpu=5206
+	tm_file="${tm_file} m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h newlib-stdint.h m68k/m68kemb.h m68k/m68k-macos.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-m68kelf m68k/t-macos"
+	tmake_file="$tmake_file m68k/t-mlibs"
+	;;
+
+fido-*-elf*)
+	default_m68k_cpu=68020
+	default_cf_cpu=5206
+	tm_file="${tm_file} m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h newlib-stdint.h m68k/m68kemb.h m68k/m68020-elf.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-m68kelf"
+	tmake_file="$tmake_file m68k/t-mlibs"
+	;;
 m68k*-*-netbsdelf*)
 	default_m68k_cpu=68020
 	default_cf_cpu=5475
@@ -3119,6 +3138,15 @@
 	extra_objs="pru-pragma.o pru-passes.o"
 	use_gcc_stdint=wrap
 	;;
+powerpc-apple-macos*)
+	tm_file="${tm_file} rs6000/xcoff.h rs6000/macos.h"
+	tmake_file="rs6000/t-macos"
+	extra_options="${extra_options} rs6000/aix64.opt"
+	use_collect2=yes
+	thread_file='aix'
+	use_gcc_stdint=provide
+	extra_headers=
+	;;
 rs6000-ibm-aix7.1.* | powerpc-ibm-aix7.1.*)
 	tmake_file="rs6000/t-aix52 t-slibgcc"
 	if test x$cpu_is_64bit = xyes; then
diff -aurN gcc-12.2.0/gcc/config.host gcc-12.2.0-retro68/gcc/config.host
--- gcc-12.2.0/gcc/config.host	2022-08-19 15:09:52.552662114 +0700
+++ gcc-12.2.0-retro68/gcc/config.host	2024-10-31 17:12:51.726999313 +0700
@@ -268,6 +268,10 @@
     out_host_hook_obj="${out_host_hook_obj} host-ppc64-darwin.o"
     host_xmake_file="${host_xmake_file} rs6000/x-darwin64"
     ;;
+  aarch64-*-darwin*)
+    out_host_hook_obj="${out_host_hook_obj} host-aarch64-darwin.o"
+    host_xmake_file="${host_xmake_file} aarch64/x-darwin"
+    ;;
   rs6000-ibm-aix* | powerpc-ibm-aix*)
     host_xmake_file="${host_xmake_file} rs6000/x-aix"
     ;;
diff -aurN gcc-12.2.0/gcc/cp/decl.cc gcc-12.2.0-retro68/gcc/cp/decl.cc
--- gcc-12.2.0/gcc/cp/decl.cc	2022-08-19 15:09:52.760664777 +0700
+++ gcc-12.2.0-retro68/gcc/cp/decl.cc	2024-10-31 17:12:52.213670740 +0700
@@ -10243,6 +10243,12 @@
 		  (IDENTIFIER_POINTER (declarator))))))
     SET_DECL_LANGUAGE (decl, lang_c);
 
+  if (attrlist && lookup_attribute ("pascal", *attrlist))
+    {
+	    // paradoxical, but true: Mac pascal function names aren't mangled.
+      SET_DECL_LANGUAGE (decl, lang_c);
+    }
+
   /* Should probably propagate const out from type to decl I bet (mrs).  */
   if (staticp)
     {
diff -aurN gcc-12.2.0/gcc/cp/parser.cc gcc-12.2.0-retro68/gcc/cp/parser.cc
--- gcc-12.2.0/gcc/cp/parser.cc	2022-08-19 15:09:52.772664930 +0700
+++ gcc-12.2.0-retro68/gcc/cp/parser.cc	2024-10-31 17:12:52.217004106 +0700
@@ -2822,6 +2822,8 @@
 static bool cp_parser_skip_to_closing_square_bracket
   (cp_parser *);
 static size_t cp_parser_skip_balanced_tokens (cp_parser *, size_t);
+static tree cp_parser_inline_opcodes
+  (cp_parser *);
 
 // -------------------------------------------------------------------------- //
 // Unevaluated Operand Guard
@@ -4357,6 +4359,7 @@
   tree string_tree;
   tree suffix_id = NULL_TREE;
   bool curr_tok_is_userdef_p = false;
+  bool pascal_string = false;
 
   tok = cp_lexer_peek_token (parser->lexer);
   if (!cp_parser_is_string_literal (tok))
@@ -4486,9 +4489,21 @@
       type = CPP_STRING;
     }
 
+  if (!strncmp((const char*)strs[0].text, "\"\\p", 3))
+    {
+       pascal_string = true;
+       /* replace \p by a valid escape sequence */
+       ((unsigned char*)strs[0].text)[2] = 'n';
+    }
+
   if ((translate ? cpp_interpret_string : cpp_interpret_string_notranslate)
       (parse_in, strs, count, &istr, type))
     {
+      if (pascal_string)
+        {
+          /* put the real string length in */
+          ((unsigned char*)istr.text)[0] = (unsigned char) (istr.len - 2);
+        }
       value = build_string (istr.len, (const char *)istr.text);
       free (CONST_CAST (unsigned char *, istr.text));
       if (count > 1)
@@ -4502,7 +4517,10 @@
 	{
 	default:
 	case CPP_STRING:
-	  TREE_TYPE (value) = char_array_type_node;
+          if (pascal_string)
+            TREE_TYPE (value) = uchar_array_type_node;
+          else
+            TREE_TYPE (value) = char_array_type_node;
 	  break;
 	case CPP_UTF8STRING:
 	  if (flag_char8_t)
@@ -22740,20 +22758,42 @@
     {
       if (function_declarator_p (declarator))
 	{
-	   if (initialization_kind == CPP_EQ)
-	     initializer = cp_parser_pure_specifier (parser);
-	   else
-	     {
-	       /* If the declaration was erroneous, we don't really
+	  if (initialization_kind == CPP_EQ)
+            {
+              if(member_p)
+                initializer = cp_parser_pure_specifier (parser);
+              else
+                {
+                  cp_token *token;
+                  cp_lexer_consume_token (parser->lexer);
+                  token = cp_lexer_peek_token (parser->lexer);
+                  if (token->keyword == RID_DEFAULT
+                      || token->keyword == RID_DELETE)
+                    {
+                      cp_lexer_consume_token (parser->lexer);
+                      maybe_warn_cpp0x (CPP0X_DEFAULTED_DELETED);
+                      initializer = token->u.value;
+                    }
+                  else
+                    {
+                      is_initialized = false;
+                      tree rawinline_attr = cp_parser_inline_opcodes (parser);
+                      decl_attributes (&decl, rawinline_attr, 0);                   
+                    }
+                }
+            }
+	  else
+	    {
+	      /* If the declaration was erroneous, we don't really
 		  know what the user intended, so just silently
 		  consume the initializer.  */
-	       if (decl != error_mark_node)
+	      if (decl != error_mark_node)
 		 error_at (tmp_init_loc, "initializer provided for function");
-	       cp_parser_skip_to_closing_parenthesis (parser,
+	      cp_parser_skip_to_closing_parenthesis (parser,
 						      /*recovering=*/true,
 						      /*or_comma=*/false,
 						      /*consume_paren=*/true);
-	     }
+	    }
 	}
       else
 	{
@@ -48325,6 +48365,49 @@
   return member_decl_opt;
 }
 
+
+static tree cp_parser_inline_opcodes(cp_parser * parser)
+{
+  tree attr_args;
+  bool braced = false;
+    
+  braced = cp_lexer_next_token_is(parser->lexer, CPP_OPEN_BRACE);
+  if(braced)
+    cp_lexer_consume_token(parser->lexer);
+  
+  vec<tree, va_gc> *expr_list = make_tree_vector ();
+
+  if(!braced || !cp_lexer_next_token_is(parser->lexer, CPP_CLOSE_BRACE))
+  {
+    for(;;)
+    {
+      tree val = cp_parser_constant_expression (parser,
+                                                /*allow_non_constant_p=*/false,
+                                                NULL);
+      val = cp_fully_fold(val);						
+      vec_safe_push (expr_list, val);
+
+      if(cp_lexer_next_token_is(parser->lexer, CPP_COMMA))
+        cp_lexer_consume_token(parser->lexer);
+      else
+        break;
+    }
+  }
+
+  attr_args = build_tree_list_vec (expr_list);
+  release_tree_vector (expr_list);
+
+  if(braced)
+    {
+      if(cp_lexer_next_token_is(parser->lexer, CPP_CLOSE_BRACE))
+        cp_lexer_consume_token(parser->lexer);
+      else
+        cp_parser_error (parser, "expected %<}%>");
+    }
+  
+  return build_tree_list (canonicalize_attr_name(get_identifier("__raw_inline__")), attr_args);
+}
+
 /* Like finish_fully_implicit_template, but to be used in error
    recovery, rearranging scopes so that we restore the state we had
    before synthesize_implicit_template_parm inserted the implement
diff -aurN gcc-12.2.0/gcc/expr.cc gcc-12.2.0-retro68/gcc/expr.cc
--- gcc-12.2.0/gcc/expr.cc	2022-08-19 15:09:52.844665852 +0700
+++ gcc-12.2.0-retro68/gcc/expr.cc	2024-10-31 17:12:52.400339233 +0700
@@ -4427,12 +4427,14 @@
       addr = XEXP (mem, 0);
       switch (GET_CODE (addr))
 	{
+#ifdef PUSH_ROUNDING
 	case PRE_INC:
 	case POST_INC:
-	  return GET_MODE_SIZE (GET_MODE (mem));
+	  return PUSH_ROUNDING( GET_MODE_SIZE (GET_MODE (mem)) );
 	case PRE_DEC:
 	case POST_DEC:
-	  return -GET_MODE_SIZE (GET_MODE (mem));
+	  return -PUSH_ROUNDING( GET_MODE_SIZE (GET_MODE (mem)) );
+#endif
 	case PRE_MODIFY:
 	case POST_MODIFY:
 	  addr = XEXP (addr, 1);
diff -aurN gcc-12.2.0/gcc/final.cc gcc-12.2.0-retro68/gcc/final.cc
--- gcc-12.2.0/gcc/final.cc	2022-08-19 15:09:52.844665852 +0700
+++ gcc-12.2.0-retro68/gcc/final.cc	2024-10-31 17:12:52.400339233 +0700
@@ -3449,6 +3449,8 @@
       and print a constant expression for minus the value
       of the operand, with no other punctuation.  */
 
+int retro68_hack_asm_rts_counter = 0;
+
 void
 output_asm_insn (const char *templ, rtx *operands)
 {
@@ -3466,6 +3468,13 @@
   if (*templ == 0)
     return;
 
+  /* Hack: in Retro68, we want to know whether the last
+           instruction we output was an rts, so we know
+           whether we have to output an extra one as part
+           of the MacsBug name. */
+  if(retro68_hack_asm_rts_counter)
+    retro68_hack_asm_rts_counter--;
+
   memset (opoutput, 0, sizeof opoutput);
   p = templ;
   putc ('\t', asm_out_file);
diff -aurN gcc-12.2.0/gcc/function.cc gcc-12.2.0-retro68/gcc/function.cc
--- gcc-12.2.0/gcc/function.cc	2022-08-19 15:09:52.876666260 +0700
+++ gcc-12.2.0-retro68/gcc/function.cc	2024-10-31 17:12:52.537007236 +0700
@@ -2412,6 +2412,20 @@
       all->function_result_decl = decl;
     }
 
+#ifdef IS_PASCAL_FUNC
+  if (IS_PASCAL_FUNC(fntype, fndecl))
+    {
+        // reverse argument order
+      unsigned n = fnargs.length(), n2 = fnargs.length() / 2;
+      for(unsigned i = 0; i < n2; i++)
+      {
+        tree tmp = fnargs[i];
+        fnargs[i] = fnargs[n - 1 - i];
+        fnargs[n - 1 - i] = tmp;
+      }
+    }
+#endif
+
   /* If the target wants to split complex arguments into scalars, do so.  */
   if (targetm.calls.split_complex_arg)
     split_complex_args (&fnargs);
@@ -5423,6 +5437,20 @@
       tree decl_result = DECL_RESULT (current_function_decl);
       rtx decl_rtl = DECL_RTL (decl_result);
 
+#ifdef IS_PASCAL_FUNC
+      if (IS_PASCAL_FUNC(TREE_TYPE(current_function_decl), current_function_decl))
+	{
+	  enum machine_mode mode = GET_MODE(decl_rtl);;
+
+	  rtx return_slot = gen_int_mode(crtl->args.pops_args + 8, Pmode);
+	  return_slot = gen_rtx_PLUS(Pmode, arg_pointer_rtx, return_slot);
+	  return_slot = gen_rtx_MEM(mode, return_slot);
+	  MEM_VOLATILE_P(return_slot) = true;
+	  emit_move_insn (return_slot, decl_rtl);
+	  crtl->return_rtx = return_slot;
+	}
+      else
+#endif
       if ((REG_P (decl_rtl)
 	   ? REGNO (decl_rtl) >= FIRST_PSEUDO_REGISTER
 	   : DECL_REGISTER (decl_result))
diff -aurN gcc-12.2.0/gcc/reload1.cc gcc-12.2.0-retro68/gcc/reload1.cc
--- gcc-12.2.0/gcc/reload1.cc	2022-08-19 15:09:53.108669230 +0700
+++ gcc-12.2.0-retro68/gcc/reload1.cc	2024-10-31 17:12:52.770342852 +0700
@@ -3028,6 +3028,8 @@
 		else
 		  ep->can_eliminate = 0;
 	      }
+            if (code == POST_DEC || code == POST_INC)
+              ep->can_eliminate = 0;
 	  }
 
       /* These two aren't unary operators.  */
diff -aurN gcc-12.2.0/gcc/rtlanal.cc gcc-12.2.0-retro68/gcc/rtlanal.cc
--- gcc-12.2.0/gcc/rtlanal.cc	2022-08-19 15:09:53.112669282 +0700
+++ gcc-12.2.0-retro68/gcc/rtlanal.cc	2024-10-31 17:12:52.773676218 +0700
@@ -1639,7 +1639,24 @@
     return 1;
 
   if (MEM_P (dst) && MEM_P (src))
-    return rtx_equal_p (dst, src) && !side_effects_p (dst);
+  {
+    if (rtx_equal_p (dst, src) && !side_effects_p (dst))
+	  return 1;
+
+    src = XEXP(src, 0); 
+	dst = XEXP(dst, 0);
+
+	if( GET_CODE(src) == POST_INC && GET_CODE(dst) == PRE_DEC )
+	{
+	  src = XEXP(src, 0);
+	  dst = XEXP(dst, 0);
+      if (rtx_equal_p (dst, src) && !side_effects_p (dst))
+	    return 1;
+
+	}
+
+    return 0;
+  }
 
   if (GET_CODE (dst) == ZERO_EXTRACT)
     return rtx_equal_p (XEXP (dst, 0), src)
diff -aurN gcc-12.2.0/gcc/system.h gcc-12.2.0-retro68/gcc/system.h
--- gcc-12.2.0/gcc/system.h	2022-08-19 15:09:53.120669384 +0700
+++ gcc-12.2.0-retro68/gcc/system.h	2024-10-31 17:12:52.780342950 +0700
@@ -145,7 +145,7 @@
 extern char *fgets_unlocked (char *, int, FILE *);
 #  endif
 # endif
-# ifdef HAVE_FPUTS_UNLOCKED
+# if defined (HAVE_FPUTS_UNLOCKED) && !defined (__CYGWIN__)
 #  undef fputs
 #  define fputs(String, Stream) fputs_unlocked (String, Stream)
 #  if defined (HAVE_DECL_FPUTS_UNLOCKED) && !HAVE_DECL_FPUTS_UNLOCKED
@@ -194,28 +194,6 @@
 #undef fread_unlocked
 #undef fwrite_unlocked
 
-/* Include <string> before "safe-ctype.h" to avoid GCC poisoning
-   the ctype macros through safe-ctype.h */
-
-#ifdef __cplusplus
-#ifdef INCLUDE_STRING
-# include <string>
-#endif
-#endif
-
-/* There are an extraordinary number of issues with <ctype.h>.
-   The last straw is that it varies with the locale.  Use libiberty's
-   replacement instead.  */
-#include "safe-ctype.h"
-
-#include <sys/types.h>
-
-#include <errno.h>
-
-#if !defined (errno) && defined (HAVE_DECL_ERRNO) && !HAVE_DECL_ERRNO
-extern int errno;
-#endif
-
 #ifdef __cplusplus
 #if defined (INCLUDE_ALGORITHM) || !defined (HAVE_SWAP_IN_UTILITY)
 # include <algorithm>
@@ -229,6 +207,11 @@
 #ifdef INCLUDE_SET
 # include <set>
 #endif
+/* Include <string> before "safe-ctype.h" to avoid GCC poisoning
+   the ctype macros through safe-ctype.h */
+#ifdef INCLUDE_STRING
+# include <string>
+#endif
 #ifdef INCLUDE_VECTOR
 # include <vector>
 #endif
@@ -245,6 +228,17 @@
 # include <type_traits>
 #endif
 
+/* There are an extraordinary number of issues with <ctype.h>.
+   The last straw is that it varies with the locale.  Use libiberty's
+   replacement instead.  */
+#include "safe-ctype.h"
+#include <sys/types.h>
+#include <errno.h>
+
+#if !defined (errno) && defined (HAVE_DECL_ERRNO) && !HAVE_DECL_ERRNO
+extern int errno;
+#endif
+
 /* Some of glibc's string inlines cause warnings.  Plus we'd rather
    rely on (and therefore test) GCC's string builtins.  */
 #define __NO_STRING_INLINES
diff -aurN gcc-12.2.0/libbacktrace/config.h.in gcc-12.2.0-retro68/libbacktrace/config.h.in
--- gcc-12.2.0/libbacktrace/config.h.in	2022-08-19 15:09:54.608688432 +0700
+++ gcc-12.2.0-retro68/libbacktrace/config.h.in	2024-10-31 17:13:29.857372709 +0700
@@ -100,8 +100,7 @@
 /* Define if -lz is available. */
 #undef HAVE_ZLIB
 
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
 #undef LT_OBJDIR
 
 /* Define to the address where bug reports for this package should be sent. */
diff -aurN gcc-12.2.0/libcc1/cc1plugin-config.h.in gcc-12.2.0-retro68/libcc1/cc1plugin-config.h.in
--- gcc-12.2.0/libcc1/cc1plugin-config.h.in	2022-08-19 15:09:54.612688483 +0700
+++ gcc-12.2.0-retro68/libcc1/cc1plugin-config.h.in	2024-10-31 17:13:29.874039538 +0700
@@ -34,8 +34,7 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
 #undef LT_OBJDIR
 
 /* Define to the address where bug reports for this package should be sent. */
diff -aurN gcc-12.2.0/libcc1/libcc1plugin.cc gcc-12.2.0-retro68/libcc1/libcc1plugin.cc
--- gcc-12.2.0/libcc1/libcc1plugin.cc	2022-08-19 15:09:54.616688533 +0700
+++ gcc-12.2.0-retro68/libcc1/libcc1plugin.cc	2024-10-31 17:13:29.874039538 +0700
@@ -31,6 +31,7 @@
 #undef PACKAGE_TARNAME
 #undef PACKAGE_VERSION
 
+#define INCLUDE_VECTOR
 #define INCLUDE_MEMORY
 #include "gcc-plugin.h"
 #include "system.h"
@@ -69,7 +70,6 @@
 #include "gcc-c-interface.h"
 #include "context.hh"
 
-#include <vector>
 
 using namespace cc1_plugin;
 
diff -aurN gcc-12.2.0/libcc1/libcp1plugin.cc gcc-12.2.0-retro68/libcc1/libcp1plugin.cc
--- gcc-12.2.0/libcc1/libcp1plugin.cc	2022-08-19 15:09:54.616688533 +0700
+++ gcc-12.2.0-retro68/libcc1/libcp1plugin.cc	2024-10-31 17:13:29.877372905 +0700
@@ -33,6 +33,7 @@
 #undef PACKAGE_VERSION
 
 #define INCLUDE_MEMORY
+#define INCLUDE_VECTOR
 #include "gcc-plugin.h"
 #include "system.h"
 #include "coretypes.h"
@@ -71,7 +72,6 @@
 #include "rpc.hh"
 #include "context.hh"
 
-#include <vector>
 
 using namespace cc1_plugin;
 
diff -aurN gcc-12.2.0/libcpp/charset.cc gcc-12.2.0-retro68/libcpp/charset.cc
--- gcc-12.2.0/libcpp/charset.cc	2022-08-19 15:09:54.620688586 +0700
+++ gcc-12.2.0-retro68/libcpp/charset.cc	2024-10-31 17:13:29.890706369 +0700
@@ -1954,7 +1954,7 @@
       cpp_error (pfile, type == CPP_UTF8CHAR ? CPP_DL_ERROR : CPP_DL_WARNING,
 		 "character constant too long for its type");
     }
-  else if (i > 1 && CPP_OPTION (pfile, warn_multichar))
+  else if (i > 1 && i != 4 && CPP_OPTION (pfile, warn_multichar))
     cpp_warning (pfile, CPP_W_MULTICHAR, "multi-character character constant");
 
   /* Multichar constants are of type int and therefore signed.  */
diff -aurN gcc-12.2.0/libgcc/config/rs6000/cxa_finalize.c gcc-12.2.0-retro68/libgcc/config/rs6000/cxa_finalize.c
--- gcc-12.2.0/libgcc/config/rs6000/cxa_finalize.c	2022-08-19 15:09:54.720689865 +0700
+++ gcc-12.2.0-retro68/libgcc/config/rs6000/cxa_finalize.c	2024-10-31 17:13:30.477378786 +0700
@@ -29,7 +29,7 @@
 #include "exit.h"
 
 
-static boolean_t
+static int
 catomic_compare_and_exchange_bool_acq (long *mem, long newval, long oldval)
 {
   return ! __atomic_compare_exchange (mem, &oldval, &newval, 0,
diff -aurN gcc-12.2.0/libgcc/config.host gcc-12.2.0-retro68/libgcc/config.host
--- gcc-12.2.0/libgcc/config.host	2022-08-19 15:09:54.664689148 +0700
+++ gcc-12.2.0-retro68/libgcc/config.host	2024-10-31 17:13:30.090708330 +0700
@@ -962,6 +962,10 @@
 m68k-*-elf* | fido-*-elf)
 	tmake_file="$tmake_file m68k/t-floatlib"
 	;;
+m68k-*-macos)
+	extra_parts="crtbegin.o crtend.o"
+	tmake_file="$tmake_file m68k/t-floatlib"
+	;;
 m68k*-*-netbsdelf*)
 	;;
 m68k*-*-openbsd*)
@@ -1327,6 +1331,9 @@
 	tmake_file="t-fdpbit rs6000/t-ppc64-fp rs6000/t-slibgcc-aix rs6000/t-ibm-ldouble rs6000/t-aix-cxa"
 	extra_parts="crtcxa.o crtcxa_s.o crtdbase.o crtcxa_64.o crtcxa_64_s.o crtdbase_64.o"
 	;;
+powerpc-*-macos)
+	tmake_file="t-fdpbit rs6000/t-ibm-ldouble"
+	;;
 rl78-*-elf)
 	tmake_file="$tm_file t-fdpbit rl78/t-rl78"
 	;;
diff -aurN gcc-12.2.0/libgcc/Makefile.in gcc-12.2.0-retro68/libgcc/Makefile.in
--- gcc-12.2.0/libgcc/Makefile.in	2022-08-19 15:09:54.664689148 +0700
+++ gcc-12.2.0-retro68/libgcc/Makefile.in	2024-10-31 17:13:30.090708330 +0700
@@ -247,6 +247,7 @@
 LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(HOST_LIBGCC2_CFLAGS) \
 		 $(LIBGCC2_DEBUG_CFLAGS) -DIN_LIBGCC2 \
 		 -fbuilding-libgcc -fno-stack-protector \
+		 -ffunction-sections \
 		 $(INHIBIT_LIBC_CFLAGS)
 
 # Additional options to use when compiling libgcc2.a.
diff -aurN gcc-12.2.0/libstdc++-v3/config.h.in gcc-12.2.0-retro68/libstdc++-v3/config.h.in
--- gcc-12.2.0/libstdc++-v3/config.h.in	2022-08-19 15:09:55.380698313 +0700
+++ gcc-12.2.0-retro68/libstdc++-v3/config.h.in	2024-10-31 17:13:34.177415066 +0700
@@ -735,8 +735,7 @@
 /* Define as const if the declaration of iconv() needs const. */
 #undef ICONV_CONST
 
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
 #undef LT_OBJDIR
 
 /* Name of package */
diff -aurN gcc-12.2.0/lto-plugin/config.h.in gcc-12.2.0-retro68/lto-plugin/config.h.in
--- gcc-12.2.0/lto-plugin/config.h.in	2022-08-19 15:09:55.760703177 +0700
+++ gcc-12.2.0-retro68/lto-plugin/config.h.in	2024-10-31 17:13:39.190797566 +0700
@@ -33,8 +33,7 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
 #undef LT_OBJDIR
 
 /* Name of package */
