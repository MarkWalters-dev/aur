diff --git a/clang-tools-extra/clangd/Hover.cpp b/clang-tools-extra/clangd/Hover.cpp
index 80aac07f0437..073f03d16469 100644
--- a/clang-tools-extra/clangd/Hover.cpp
+++ b/clang-tools-extra/clangd/Hover.cpp
@@ -185,8 +185,12 @@ HoverInfo::PrintedType printType(QualType QT, ASTContext &ASTCtx,
   if (!QT.isNull() && Cfg.Hover.ShowAKA) {
     bool ShouldAKA = false;
     QualType DesugaredTy = clang::desugarForDiagnostic(ASTCtx, QT, ShouldAKA);
-    if (ShouldAKA)
+    if (ShouldAKA) {
       Result.AKA = DesugaredTy.getAsString(PP);
+      if (Result.Type.length() > 16 &&
+          Result.AKA->length() < Result.Type.length())
+        std::swap(*Result.AKA, Result.Type);
+    }
   }
   return Result;
 }
@@ -1430,6 +1434,142 @@ static std::string formatOffset(uint64_t OffsetInBits) {
   return Offset;
 }
 
+// If the backtick at `Offset` starts a probable quoted range, return the range
+// (including the quotes).
+static std::optional<llvm::StringRef>
+getBacktickQuoteRange(llvm::StringRef Line, unsigned Offset,
+                      llvm::StringRef Quote = "`") {
+  assert(Line.substr(Offset, Quote.size()) == Quote);
+
+  // The open-quote is usually preceded by whitespace.
+  llvm::StringRef Prefix = Line.substr(0, Offset);
+  constexpr llvm::StringLiteral BeforeStartChars = " \t(=";
+  if (!Prefix.empty() && !BeforeStartChars.contains(Prefix.back()))
+    return std::nullopt;
+
+  // The quoted string must be nonempty and usually has no leading/trailing ws.
+  auto Next = Line.find(Quote, Offset + Quote.size());
+  if (Next == llvm::StringRef::npos)
+    return std::nullopt;
+  llvm::StringRef Contents = Line.slice(Offset + Quote.size(), Next);
+  if (Contents.empty() || isWhitespace(Contents.front()) ||
+      isWhitespace(Contents.back()))
+    return std::nullopt;
+
+  // The close-quote is usually followed by whitespace or punctuation.
+  llvm::StringRef Suffix = Line.substr(Next + Quote.size());
+  constexpr llvm::StringLiteral AfterEndChars = " \t)=.,;:";
+  if (!Suffix.empty() && !AfterEndChars.contains(Suffix.front()))
+    return std::nullopt;
+
+  return Line.slice(Offset, Next + Quote.size());
+}
+
+static void parseDocumentationLine(llvm::StringRef Line,
+                                   markup::Paragraph &Out) {
+  // Probably this is appendText(Line), but scan for something interesting.
+  for (unsigned I = 0; I < Line.size(); ++I) {
+    switch (Line[I]) {
+    case '`':
+      if (auto Range = getBacktickQuoteRange(Line, I)) {
+        Out.appendText(Line.substr(0, I));
+        Out.appendCode(Range->trim("`"), /*Preserve=*/true);
+        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
+      }
+      break;
+    case '\\':
+      Out.appendText(Line.substr(0, I));
+      Out.appendText(Line.substr(I + 1, 1));
+      return parseDocumentationLine(Line.substr(I + 2), Out);
+    case '*':
+      if (Line[I + 1] == '*') {
+        if (auto Range = getBacktickQuoteRange(Line, I, "**")) {
+          Out.appendText(Line.substr(0, I));
+          Out.appendBoldText(Range->trim("**"));
+          return parseDocumentationLine(Line.substr(I + Range->size()), Out);
+        }
+      }
+      if (auto Range = getBacktickQuoteRange(Line, I, "*")) {
+        Out.appendText(Line.substr(0, I));
+        Out.appendItalicText(Range->trim("*"));
+        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
+      }
+      break;
+    }
+  }
+  Out.appendText(Line).appendSpace();
+}
+
+static void
+presentOneParam(const HoverInfo::Param &Param,
+                const llvm::SmallVector<ParameterDocumentationOwned> &ParamDocs,
+                markup::BulletList &Output) {
+  auto &Paragraph = Output.addItem().addParagraph();
+
+  if (!Param.Name) {
+    Paragraph.appendCode(llvm::to_string(Param));
+    return;
+  }
+
+  // Strip system prefixes.
+  // E.g. for `char *strcpy (char * __dest, const char * __src)`, the `__dest`
+  // and `__src` will strip `__`. To get `dest` and `src`
+  std::size_t From = 0;
+  while ((*Param.Name)[From] == '_')
+    ++From;
+  auto Name = llvm::StringRef(*Param.Name).substr(From);
+
+  if (Param.Default)
+    Paragraph.appendCode(Name.str() + " = " + *Param.Default);
+  else
+    Paragraph.appendCode(Name);
+  Paragraph.appendText(": ");
+
+  auto *ParamDoc = std::find_if(
+      ParamDocs.begin(), ParamDocs.end(),
+      [Param](const auto &ParamDoc) { return Param.Name == ParamDoc.Name; });
+  if (ParamDoc != ParamDocs.end())
+    parseDocumentationLine(ParamDoc->Description, Paragraph);
+
+  if (Param.Type)
+    Paragraph.appendText(" (")
+        .appendCode(llvm::to_string(*Param.Type))
+        .appendText(")");
+}
+
+static void
+presentParams(std::string ParagraphName,
+              const std::optional<std::vector<HoverInfo::Param>> &Params,
+              const llvm::SmallVector<ParameterDocumentationOwned> &ParamDocs,
+              markup::Document &Output) {
+  if (!Params || Params->empty())
+    return;
+
+  auto It = Params->begin();
+  if (!It->Default) {
+    Output.addParagraph().appendText(ParagraphName + ": ");
+    markup::BulletList &ReqList = Output.addBulletList();
+
+    for (; It != Params->end() && !It->Default; ++It) {
+      presentOneParam(*It, ParamDocs, ReqList);
+    }
+  }
+
+  if (It == Params->end())
+    return;
+
+  if (std::isupper(ParagraphName.front())) {
+    ParagraphName.front() = std::tolower(ParagraphName.front());
+    Output.addParagraph().appendText("Optional " + ParagraphName + ": ");
+  } else
+    Output.addParagraph().appendText("optional " + ParagraphName + ": ");
+  markup::BulletList &OptList = Output.addBulletList();
+
+  for (; It != Params->end(); ++It) {
+    presentOneParam(*It, ParamDocs, OptList);
+  }
+}
+
 markup::Document HoverInfo::present() const {
   markup::Document Output;
 
@@ -1465,6 +1605,9 @@ markup::Document HoverInfo::present() const {
   if (!Documentation.Brief.empty())
     parseDocumentation(Documentation.Brief, Output);
 
+  presentParams("Template parameters", TemplateParameters,
+                Documentation.TemplateParameters, Output);
+
   // Print Types on their own lines to reduce chances of getting line-wrapped by
   // editor, as they might be long.
   if (ReturnType) {
@@ -1473,44 +1616,20 @@ markup::Document HoverInfo::present() const {
     // Parameters:
     // - `bool param1`
     // - `int param2 = 5`
-    auto &P = Output.addParagraph().appendText("→ ").appendCode(
-        llvm::to_string(*ReturnType));
+    auto &P =
+        Output.addParagraph().appendText("→ ").appendCode(ReturnType->Type);
 
     if (!Documentation.Returns.empty())
-      P.appendText(": ").appendText(Documentation.Returns);
-  }
-  if (Parameters && !Parameters->empty()) {
-    Output.addParagraph().appendText("Parameters: ");
-    markup::BulletList &L = Output.addBulletList();
+      parseDocumentationLine(Documentation.Returns, P.appendText(": "));
 
-    llvm::SmallVector<ParameterDocumentationOwned> ParamDocs =
-        Documentation.Parameters;
-
-    for (const auto &Param : *Parameters) {
-      auto &Paragraph = L.addItem().addParagraph();
-      Paragraph.appendCode(llvm::to_string(Param));
-
-      if (Param.Name.has_value()) {
-        auto ParamDoc = std::find_if(ParamDocs.begin(), ParamDocs.end(),
-                                     [Param](const auto &ParamDoc) {
-                                       return Param.Name == ParamDoc.Name;
-                                     });
-        if (ParamDoc != ParamDocs.end()) {
-          Paragraph.appendText(": ").appendText(ParamDoc->Description);
-          ParamDocs.erase(ParamDoc);
-        }
-      }
-    }
+    if (ReturnType->AKA)
+      P.appendCode(" (aka " + *ReturnType->AKA + ")");
+  }
+  presentParams("Parameters", Parameters, Documentation.Parameters, Output);
 
-    // We erased all parameters that matched, but some may still be left,
-    // usually typos. Let's also print them here.
-    for (const auto &ParamDoc : ParamDocs) {
-      L.addItem()
-          .addParagraph()
-          .appendCode(ParamDoc.Name)
-          .appendText(": ")
-          .appendText(ParamDoc.Description);
-    }
+  if (!Documentation.Details.empty()) {
+    Output.addParagraph().appendText("Details: ");
+    parseDocumentation(Documentation.Details, Output);
   }
 
   // Don't print Type after Parameters or ReturnType as this will just duplicate
@@ -1582,6 +1701,39 @@ markup::Document HoverInfo::present() const {
       parseDocumentation(Note, L.addItem());
   }
 
+  if (!Documentation.Exceptions.empty()) {
+    Output.addRuler();
+    Output.addParagraph()
+        .appendText("Exception")
+        .appendText(Documentation.Exceptions.size() > 1 ? "s" : "")
+        .appendText(": ");
+    markup::BulletList &L = Output.addBulletList();
+    for (const auto &Exception : Documentation.Exceptions)
+      parseDocumentation(Exception, L.addItem());
+  }
+
+  if (!Documentation.Bugs.empty()) {
+    Output.addRuler();
+    Output.addParagraph()
+        .appendText("Bug")
+        .appendText(Documentation.Bugs.size() > 1 ? "s" : "")
+        .appendText(": ");
+    markup::BulletList &L = Output.addBulletList();
+    for (const auto &Bug : Documentation.Bugs)
+      parseDocumentation(Bug, L.addItem());
+  }
+
+  if (!Documentation.Todos.empty()) {
+    Output.addRuler();
+    Output.addParagraph()
+        .appendText("Todo")
+        .appendText(Documentation.Todos.size() > 1 ? "s" : "")
+        .appendText(": ");
+    markup::BulletList &L = Output.addBulletList();
+    for (const auto &Todo : Documentation.Todos)
+      parseDocumentation(Todo, L.addItem());
+  }
+
   if (!Definition.empty()) {
     Output.addRuler();
     std::string Buffer;
@@ -1632,71 +1784,6 @@ markup::Document HoverInfo::present() const {
   return Output;
 }
 
-// If the backtick at `Offset` starts a probable quoted range, return the range
-// (including the quotes).
-std::optional<llvm::StringRef>
-getBacktickQuoteRange(llvm::StringRef Line, unsigned Offset,
-                      llvm::StringRef Quote = "`") {
-  assert(Line.substr(Offset, Quote.size()) == Quote);
-
-  // The open-quote is usually preceded by whitespace.
-  llvm::StringRef Prefix = Line.substr(0, Offset);
-  constexpr llvm::StringLiteral BeforeStartChars = " \t(=";
-  if (!Prefix.empty() && !BeforeStartChars.contains(Prefix.back()))
-    return std::nullopt;
-
-  // The quoted string must be nonempty and usually has no leading/trailing ws.
-  auto Next = Line.find(Quote, Offset + Quote.size());
-  if (Next == llvm::StringRef::npos)
-    return std::nullopt;
-  llvm::StringRef Contents = Line.slice(Offset + Quote.size(), Next);
-  if (Contents.empty() || isWhitespace(Contents.front()) ||
-      isWhitespace(Contents.back()))
-    return std::nullopt;
-
-  // The close-quote is usually followed by whitespace or punctuation.
-  llvm::StringRef Suffix = Line.substr(Next + Quote.size());
-  constexpr llvm::StringLiteral AfterEndChars = " \t)=.,;:";
-  if (!Suffix.empty() && !AfterEndChars.contains(Suffix.front()))
-    return std::nullopt;
-
-  return Line.slice(Offset, Next + Quote.size());
-}
-
-void parseDocumentationLine(llvm::StringRef Line, markup::Paragraph &Out) {
-  // Probably this is appendText(Line), but scan for something interesting.
-  for (unsigned I = 0; I < Line.size(); ++I) {
-    switch (Line[I]) {
-    case '`':
-      if (auto Range = getBacktickQuoteRange(Line, I)) {
-        Out.appendText(Line.substr(0, I));
-        Out.appendCode(Range->trim("`"), /*Preserve=*/true);
-        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
-      }
-      break;
-    case '\\':
-      Out.appendText(Line.substr(0, I));
-      Out.appendText(Line.substr(I + 1, 1));
-      return parseDocumentationLine(Line.substr(I + 2), Out);
-    case '*':
-      if (Line[I + 1] == '*') {
-        if (auto Range = getBacktickQuoteRange(Line, I, "**")) {
-          Out.appendText(Line.substr(0, I));
-          Out.appendBoldText(Range->trim("**"));
-          return parseDocumentationLine(Line.substr(I + Range->size()), Out);
-        }
-      }
-      if (auto Range = getBacktickQuoteRange(Line, I, "*")) {
-        Out.appendText(Line.substr(0, I));
-        Out.appendItalicText(Range->trim("*"));
-        return parseDocumentationLine(Line.substr(I + Range->size()), Out);
-      }
-      break;
-    }
-  }
-  Out.appendText(Line).appendSpace();
-}
-
 void parseDocumentation(llvm::StringRef Input, markup::Document &Output) {
   std::vector<llvm::StringRef> ParagraphLines;
   auto FlushParagraph = [&] {
diff --git a/clang-tools-extra/clangd/SymbolDocumentation.cpp b/clang-tools-extra/clangd/SymbolDocumentation.cpp
index 50d63f47515f..9defaa7fe53e 100644
--- a/clang-tools-extra/clangd/SymbolDocumentation.cpp
+++ b/clang-tools-extra/clangd/SymbolDocumentation.cpp
@@ -106,11 +106,22 @@ public:
     // Otherwise, we want to keep the command name, so visit B itself.
     if (CommandName == "brief") {
       BlockCommentToString(Output.Brief, Ctx).visit(B->getParagraph());
+    } else if (CommandName == "details") {
+      BlockCommentToString(Output.Details, Ctx).visit(B->getParagraph());
     } else if (CommandName == "return") {
       BlockCommentToString(Output.Returns, Ctx).visit(B->getParagraph());
     } else if (CommandName == "warning") {
       BlockCommentToString(Output.Warnings.emplace_back(), Ctx)
           .visit(B->getParagraph());
+    } else if (CommandName == "exception" || CommandName == "throw") {
+      BlockCommentToString(Output.Exceptions.emplace_back(), Ctx)
+          .visit(B->getParagraph());
+    } else if (CommandName == "todo") {
+      BlockCommentToString(Output.Todos.emplace_back(), Ctx)
+          .visit(B->getParagraph());
+    } else if (CommandName == "bug") {
+      BlockCommentToString(Output.Bugs.emplace_back(), Ctx)
+          .visit(B->getParagraph());
     } else if (CommandName == "note") {
       BlockCommentToString(Output.Notes.emplace_back(), Ctx)
           .visit(B->getParagraph());
@@ -135,6 +146,15 @@ public:
     }
   }
 
+  void visitTParamCommandComment(const comments::TParamCommandComment *P) {
+    if (P->hasParamName() && P->hasNonWhitespaceParagraph()) {
+      ParameterDocumentationOwned Doc;
+      Doc.Name = P->getParamNameAsWritten().str();
+      BlockCommentToString(Doc.Description, Ctx).visit(P->getParagraph());
+      Output.TemplateParameters.push_back(std::move(Doc));
+    }
+  }
+
 private:
   comments::FullComment *FullComment;
   SymbolDocumentationOwned &Output;
@@ -149,16 +169,25 @@ SymbolDocumentationOwned parseDoxygenComment(const RawComment &RC,
 
   // Clang requires source to be UTF-8, but doesn't enforce this in comments.
   ensureUTF8(Doc.Brief);
+  ensureUTF8(Doc.Details);
   ensureUTF8(Doc.Returns);
 
   ensureUTF8(Doc.Notes);
   ensureUTF8(Doc.Warnings);
+  ensureUTF8(Doc.Exceptions);
+  ensureUTF8(Doc.Todos);
+  ensureUTF8(Doc.Bugs);
 
   for (auto &Param : Doc.Parameters) {
     ensureUTF8(Param.Name);
     ensureUTF8(Param.Description);
   }
 
+  for (auto &Param : Doc.TemplateParameters) {
+    ensureUTF8(Param.Name);
+    ensureUTF8(Param.Description);
+  }
+
   ensureUTF8(Doc.Description);
   ensureUTF8(Doc.CommentText);
 
@@ -173,6 +202,7 @@ SymbolDocumentation<StrOut> convert(const SymbolDocumentation<StrIn> &In) {
   SymbolDocumentation<StrOut> Doc;
 
   Doc.Brief = In.Brief;
+  Doc.Details = In.Details;
   Doc.Returns = In.Returns;
 
   Doc.Notes.reserve(In.Notes.size());
@@ -185,12 +215,33 @@ SymbolDocumentation<StrOut> convert(const SymbolDocumentation<StrIn> &In) {
     Doc.Warnings.emplace_back(Warning);
   }
 
+  Doc.Exceptions.reserve(In.Exceptions.size());
+  for (const auto &Exception : In.Exceptions) {
+    Doc.Exceptions.emplace_back(Exception);
+  }
+
+  Doc.Todos.reserve(In.Todos.size());
+  for (const auto &Todo : In.Todos) {
+    Doc.Todos.emplace_back(Todo);
+  }
+
+  Doc.Bugs.reserve(In.Bugs.size());
+  for (const auto &Bug : In.Bugs) {
+    Doc.Bugs.emplace_back(Bug);
+  }
+
   Doc.Parameters.reserve(In.Parameters.size());
   for (const auto &ParamDoc : In.Parameters) {
     Doc.Parameters.emplace_back(ParameterDocumentation<StrOut>{
         StrOut(ParamDoc.Name), StrOut(ParamDoc.Description)});
   }
 
+  Doc.TemplateParameters.reserve(In.TemplateParameters.size());
+  for (const auto &ParamDoc : In.TemplateParameters) {
+    Doc.TemplateParameters.emplace_back(ParameterDocumentation<StrOut>{
+        StrOut(ParamDoc.Name), StrOut(ParamDoc.Description)});
+  }
+
   Doc.Description = In.Description;
   Doc.CommentText = In.CommentText;
 
diff --git a/clang-tools-extra/clangd/SymbolDocumentation.h b/clang-tools-extra/clangd/SymbolDocumentation.h
index 77bd90927802..0c9db8653f22 100644
--- a/clang-tools-extra/clangd/SymbolDocumentation.h
+++ b/clang-tools-extra/clangd/SymbolDocumentation.h
@@ -65,6 +65,9 @@ public:
   /// Paragraph of the "brief" command.
   String Brief;
 
+  /// Paragraph of the "details" command.
+  String Details;
+
   /// Paragraph of the "return" command.
   String Returns;
 
@@ -72,10 +75,19 @@ public:
   llvm::SmallVector<String, 1> Notes;
   /// Paragraph(s) of the "warning" command(s)
   llvm::SmallVector<String, 1> Warnings;
+  /// Paragraph(s) of the "exception" command(s)
+  llvm::SmallVector<String, 1> Exceptions;
+  /// Paragraph(s) of the "todo" command(s)
+  llvm::SmallVector<String, 1> Todos;
+  /// Paragraph(s) of the "bug" command(s)
+  llvm::SmallVector<String, 1> Bugs;
 
   /// Parsed paragaph(s) of the "param" comamnd(s)
   llvm::SmallVector<ParameterDocumentation<String>> Parameters;
 
+  /// Parsed paragaph(s) of the "tparam" comamnd(s)
+  llvm::SmallVector<ParameterDocumentation<String>> TemplateParameters;
+
   /// All the paragraphs we don't have any special handling for,
   /// e.g. "details".
   String Description;
diff --git a/clang-tools-extra/clangd/index/Serialization.cpp b/clang-tools-extra/clangd/index/Serialization.cpp
index 69af71058649..253f1b9108e8 100644
--- a/clang-tools-extra/clangd/index/Serialization.cpp
+++ b/clang-tools-extra/clangd/index/Serialization.cpp
@@ -287,6 +287,7 @@ void writeSymbolDocumentation(const SymbolDocumentationRef &Doc,
                               const StringTableOut &Strings,
                               llvm::raw_ostream &OS) {
   writeVar(Strings.index(Doc.Brief), OS);
+  writeVar(Strings.index(Doc.Details), OS);
   writeVar(Strings.index(Doc.Returns), OS);
 
   writeVar(Doc.Notes.size(), OS);
@@ -297,12 +298,30 @@ void writeSymbolDocumentation(const SymbolDocumentationRef &Doc,
   for (const auto &Warning : Doc.Warnings)
     writeVar(Strings.index(Warning), OS);
 
+  writeVar(Doc.Exceptions.size(), OS);
+  for (const auto &Exception : Doc.Exceptions)
+    writeVar(Strings.index(Exception), OS);
+
+  writeVar(Doc.Todos.size(), OS);
+  for (const auto &Todo : Doc.Todos)
+    writeVar(Strings.index(Todo), OS);
+
+  writeVar(Doc.Bugs.size(), OS);
+  for (const auto &Bug : Doc.Bugs)
+    writeVar(Strings.index(Bug), OS);
+
   writeVar(Doc.Parameters.size(), OS);
   for (const auto &ParamDoc : Doc.Parameters) {
     writeVar(Strings.index(ParamDoc.Name), OS);
     writeVar(Strings.index(ParamDoc.Description), OS);
   }
 
+  writeVar(Doc.TemplateParameters.size(), OS);
+  for (const auto &ParamDoc : Doc.TemplateParameters) {
+    writeVar(Strings.index(ParamDoc.Name), OS);
+    writeVar(Strings.index(ParamDoc.Description), OS);
+  }
+
   writeVar(Strings.index(Doc.Description), OS);
   writeVar(Strings.index(Doc.CommentText), OS);
 }
@@ -311,6 +330,7 @@ SymbolDocumentationRef
 readSymbolDocumentation(Reader &Data, llvm::ArrayRef<llvm::StringRef> Strings) {
   SymbolDocumentationRef Doc;
   Doc.Brief = Data.consumeString(Strings);
+  Doc.Details = Data.consumeString(Strings);
   Doc.Returns = Data.consumeString(Strings);
 
   if (!Data.consumeSize(Doc.Notes))
@@ -323,11 +343,31 @@ readSymbolDocumentation(Reader &Data, llvm::ArrayRef<llvm::StringRef> Strings) {
   for (auto &Warning : Doc.Warnings)
     Warning = Data.consumeString(Strings);
 
+  if (!Data.consumeSize(Doc.Exceptions))
+    return Doc;
+  for (auto &Exception : Doc.Exceptions)
+    Exception = Data.consumeString(Strings);
+
+  if (!Data.consumeSize(Doc.Todos))
+    return Doc;
+  for (auto &Todo : Doc.Todos)
+    Todo = Data.consumeString(Strings);
+
+  if (!Data.consumeSize(Doc.Bugs))
+    return Doc;
+  for (auto &Bug : Doc.Bugs)
+    Bug = Data.consumeString(Strings);
+
   if (!Data.consumeSize(Doc.Parameters))
     return Doc;
   for (auto &ParamDoc : Doc.Parameters)
     ParamDoc = {Data.consumeString(Strings), Data.consumeString(Strings)};
 
+  if (!Data.consumeSize(Doc.TemplateParameters))
+    return Doc;
+  for (auto &ParamDoc : Doc.TemplateParameters)
+    ParamDoc = {Data.consumeString(Strings), Data.consumeString(Strings)};
+
   Doc.Description = Data.consumeString(Strings);
   Doc.CommentText = Data.consumeString(Strings);
 
diff --git a/clang-tools-extra/clangd/index/Symbol.h b/clang-tools-extra/clangd/index/Symbol.h
index 9c6c94f4b685..cd7fefc5b01b 100644
--- a/clang-tools-extra/clangd/index/Symbol.h
+++ b/clang-tools-extra/clangd/index/Symbol.h
@@ -177,15 +177,26 @@ template <typename Callback> void visitStrings(Symbol &S, const Callback &CB) {
   CB(S.CompletionSnippetSuffix);
 
   CB(S.Documentation.Brief);
+  CB(S.Documentation.Details);
   CB(S.Documentation.Returns);
   for (auto &Note : S.Documentation.Notes)
     CB(Note);
   for (auto &Warning : S.Documentation.Warnings)
     CB(Warning);
+  for (auto &Exception : S.Documentation.Exceptions)
+    CB(Exception);
+  for (auto &Todo : S.Documentation.Todos)
+    CB(Todo);
+  for (auto &Bug : S.Documentation.Bugs)
+    CB(Bug);
   for (auto &ParamDoc : S.Documentation.Parameters) {
     CB(ParamDoc.Name);
     CB(ParamDoc.Description);
   }
+  for (auto &ParamDoc : S.Documentation.TemplateParameters) {
+    CB(ParamDoc.Name);
+    CB(ParamDoc.Description);
+  }
   CB(S.Documentation.Description);
   CB(S.Documentation.CommentText);
 
diff --git a/clang-tools-extra/clangd/index/YAMLSerialization.cpp b/clang-tools-extra/clangd/index/YAMLSerialization.cpp
index e87c777d8966..7fc25fcb5915 100644
--- a/clang-tools-extra/clangd/index/YAMLSerialization.cpp
+++ b/clang-tools-extra/clangd/index/YAMLSerialization.cpp
@@ -234,12 +234,17 @@ template <> struct MappingTraits<ParameterDocumentationRef> {
 template <> struct MappingTraits<SymbolDocumentationRef> {
   static void mapping(IO &IO, SymbolDocumentationRef &Doc) {
     IO.mapOptional("Brief", Doc.Brief);
+    IO.mapOptional("Details", Doc.Details);
     IO.mapOptional("Returns", Doc.Returns);
 
     IO.mapOptional("Notes", Doc.Notes);
     IO.mapOptional("Warnings", Doc.Warnings);
+    IO.mapOptional("Exceptions", Doc.Exceptions);
+    IO.mapOptional("Todos", Doc.Todos);
+    IO.mapOptional("Bugs", Doc.Bugs);
 
     IO.mapOptional("Parameters", Doc.Parameters);
+    IO.mapOptional("TemplateParameters", Doc.TemplateParameters);
 
     IO.mapOptional("Description", Doc.Description);
     IO.mapOptional("CommentText", Doc.CommentText);
diff --git a/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h b/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h
index 12c955c458cc..e79a261a480a 100644
--- a/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h
+++ b/clang-tools-extra/clangd/unittests/SymbolDocumentationMatchers.h
@@ -32,11 +32,18 @@ matchesDoc(const SymbolDocumentation<S> &Expected) {
 
   return AllOf(
       Field("Brief", &SymbolDocumentation<S>::Brief, Expected.Brief),
+      Field("Details", &SymbolDocumentation<S>::Details, Expected.Details),
       Field("Returns", &SymbolDocumentation<S>::Returns, Expected.Returns),
       Field("Notes", &SymbolDocumentation<S>::Notes,
             ElementsAreArray(Expected.Notes)),
       Field("Warnings", &SymbolDocumentation<S>::Warnings,
             ElementsAreArray(Expected.Warnings)),
+      Field("Exceptions", &SymbolDocumentation<S>::Exceptions,
+            ElementsAreArray(Expected.Exceptions)),
+      Field("TODO", &SymbolDocumentation<S>::Todos,
+            ElementsAreArray(Expected.Todos)),
+      Field("Bugs", &SymbolDocumentation<S>::Bugs,
+            ElementsAreArray(Expected.Bugs)),
       Field("Parameters", &SymbolDocumentation<S>::Parameters,
             ElementsAreArray(ParamMatchers)),
       Field("Description", &SymbolDocumentation<S>::Description,
