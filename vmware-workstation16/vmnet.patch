--- a/vmnet/Makefile
+++ b/vmnet/Makefile
@@ -43,7 +43,11 @@
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
--- a/vmnet/bridge.c
+++ b/vmnet/bridge.c
@@ -26,6 +26,9 @@
 #include <linux/slab.h>
 #include <linux/poll.h>
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 10)
+#include <net/gso.h>
+#endif
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/mm.h>
@@ -684,14 +684,11 @@
 	 }
          spin_unlock_irqrestore(&bridge->historyLock, flags);
 
-         /*
-          * We used to cli() before calling netif_rx() here. It was probably
-          * unneeded (as we never did it in netif.c, and the code worked). In
-          * any case, now that we are using netif_rx_ni(), we should certainly
-          * not do it, or netif_rx_ni() will deadlock on the cli() lock --hpreg
-          */
-
-	 netif_rx_ni(clone);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0)
+         netif_rx_ni(clone);
+#else
+         netif_rx(clone);
+#endif
 #	 if LOGLEVEL >= 4
 	 do_gettimeofday(&vnetTime);
 #	 endif
@@ -1405,7 +1405,7 @@
  *----------------------------------------------------------------------
  */
 
-void
+static void
 VNetBridgeSendLargePacket(struct sk_buff *skb,        // IN: packet to split
                           VNetBridge *bridge)         // IN: bridge
 {
--- a/vmnet/driver.c
+++ b/vmnet/driver.c
@@ -51,18 +51,6 @@
 #include "vmnetInt.h"
 
 /*
- * Initialization and creation routines from other files.
- * Putting them here reduces the need for so many header files.
- */
-
-extern int VNetUserIf_Create(VNetPort **ret);
-extern int VNetNetIf_Create(char *devName, VNetPort **ret, int hubNum);
-extern int VNetBridge_Create(char *devName, uint32 flags, VNetJack *hubJack,
-                             VNetPort **ret);
-extern int VNetUserListener_Create(uint32 classMask, VNetJack *hubJack, VNetPort **ret);
-
-
-/*
  *  Structure for cycle detection of host interfaces.  This
  *  struct is only used by VNetCycleDetectIf().
  */
@@ -279,7 +279,7 @@
 /*
  *----------------------------------------------------------------------
  *
- * init_module --
+ * LinuxDriverInit --
  *
  *      linux module entry point. Called by /sbin/insmod command.
  *      Initializes module and Registers this driver for a
@@ -295,8 +283,8 @@
  *----------------------------------------------------------------------
  */
 
-int
-init_module(void)
+static int
+LinuxDriverInit(void)
 {
    int retval;
 
@@ -358,7 +358,7 @@
 /*
  *----------------------------------------------------------------------
  *
- * cleanup_module --
+ * LinuxDriverExit --
  *
  *      Called by /sbin/rmmod.  Unregisters this driver for a
  *      vnet major #, and deinitializes the modules.  The 64-bit
@@ -374,8 +362,8 @@
  *----------------------------------------------------------------------
  */
 
-void
-cleanup_module(void)
+static void
+LinuxDriverExit(void)
 {
    unregister_chrdev(VNET_MAJOR_NUMBER, "vmnet");
    VNetProtoUnregister();
@@ -1701,3 +1701,5 @@
  * by default (i.e., neither mkinitrd nor modprobe will accept it).
  */
 MODULE_INFO(supported, "external");
+module_init(LinuxDriverInit);
+module_exit(LinuxDriverExit);
--- a/vmnet/netif.c
+++ b/vmnet/netif.c
@@ -253,7 +253,11 @@
 
    memset(&netIf->stats, 0, sizeof netIf->stats);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
    memcpy(dev->dev_addr, netIf->port.paddr, sizeof netIf->port.paddr);
+#else
+   eth_hw_addr_set(dev, netIf->port.paddr);
+#endif
 
    if (register_netdev(dev) != 0) {
       LOG(0, (KERN_NOTICE "%s: could not register network device\n",
@@ -345,7 +349,11 @@
    /* send to the host interface */
    skb->dev = netIf->dev;
    skb->protocol = eth_type_trans(skb, netIf->dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0)
    netif_rx_ni(skb);
+#else
+   netif_rx(skb);
+#endif
    netIf->stats.rx_packets++;
 
    return;
@@ -532,7 +540,11 @@
       return -EINVAL;
    }
    memcpy(netIf->port.paddr, addr->sa_data, dev->addr_len);
-   memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
+   memcpy(dev->dev_addr, netIf->port.paddr, dev->addr_len);
+#else
+   eth_hw_addr_set(dev, netIf->port.paddr);
+#endif
    return 0;
 }
 
--- a/vmnet/smac.c
+++ b/vmnet/smac.c
@@ -4116,7 +4116,7 @@
 
 void SMACINT
 SMAC_SetMac(SMACState *state,  // IN: state to update
-	    uint8 *mac)        // IN: pointer to host adapter's MAC
+	    const uint8 *mac)  // IN: pointer to host adapter's MAC
 {
    VNETKdPrintCall(("SMAC_SetMac"));
    ASSERT(state);
--- a/vmnet/smac.h
+++ b/vmnet/smac.h
@@ -72,7 +72,7 @@
 void SMACINT
 SMAC_InitState(struct SMACState **ptr);           // IN: state to alloc/init
 void SMACINT
-SMAC_SetMac(struct SMACState *state, uint8 *mac); // IN: state, and host MAC
+SMAC_SetMac(struct SMACState *state, const uint8 *mac); // IN: state, and host MAC
 void SMACINT
 SMAC_CleanupState(struct SMACState **ptr);        // IN: state to cleanup/dealloc
 
--- a/vmnet/userif.c
+++ b/vmnet/userif.c
@@ -522,6 +522,50 @@
 /*
  *----------------------------------------------------------------------
  *
+ * VNetCsumAndCopyToUser --
+ *
+ *      Checksum data and copy them to userspace.
+ *
+ * Results:
+ *      folded checksum (non-zero value) on success,
+ *      err set to 0 on success, negative errno on failure.
+ *
+ * Side effects:
+ *      Data copied to the buffer.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static unsigned int
+VNetCsumAndCopyToUser(const void *src,   // IN: Source
+                      void *dst,         // IN: Destination
+                      int len,           // IN: Bytes to copy
+                      int *err)          // OUT: Error code
+{
+   unsigned int csum;
+
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 10, 0)
+   csum = csum_and_copy_to_user(src, dst, len, 0, err);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 19, 0)
+   csum = csum_and_copy_to_user(src, dst, len);
+   *err = (csum == 0) ? -EFAULT : 0;
+#else
+   if (!user_access_begin(dst, len)) {
+      *err = -EFAULT;
+      csum = 0;
+   } else {
+      *err = 0;
+      csum = csum_partial_copy_nocheck(src, dst, len);
+      user_access_end();
+   }
+#endif
+   return csum;
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ *
  * VNetCsumCopyDatagram --
  *
  *      Copy part of datagram to userspace doing checksum at same time.
@@ -561,12 +605,7 @@
       return -EINVAL;
    }
 
-#if COMPAT_LINUX_VERSION_CHECK_LT(5, 10, 0)
-   csum = csum_and_copy_to_user(skb->data + offset, curr, len, 0, &err);
-#else
-   csum = csum_and_copy_to_user(skb->data + offset, curr, len);
-   err = (csum == 0) ? -EFAULT : 0;
-#endif
+   csum = VNetCsumAndCopyToUser(skb->data + offset, curr, len, &err);
    if (err) {
       return err;
    }
@@ -580,14 +619,8 @@
 	 const void *vaddr;
 
 	 vaddr = kmap(skb_frag_page(frag));
-#if COMPAT_LINUX_VERSION_CHECK_LT(5, 10, 0)
-	 tmpCsum = csum_and_copy_to_user(vaddr + skb_frag_off(frag),
-					 curr, skb_frag_size(frag), 0, &err);
-#else
-	 tmpCsum = csum_and_copy_to_user(vaddr + skb_frag_off(frag),
-					 curr, skb_frag_size(frag));
-         err = (tmpCsum == 0) ? -EFAULT : 0;
-#endif
+         tmpCsum = VNetCsumAndCopyToUser(vaddr + skb_frag_off(frag),
+                                         curr, skb_frag_size(frag), &err);
 	 kunmap(skb_frag_page(frag));
 
 	 if (err) {
Fixing VMWare Player on Linux when using DHCP addresses: https://www.nikhef.nl/~janjust/vmnet/
@@ -998,6 +998,9 @@
    userIf = (VNetUserIF *)port->jack.private;
    hubJack = port->jack.peer;
 
+   /* never send link down events */
+   if (!linkUp) return 0;
+
    if (port->jack.state == FALSE || hubJack == NULL) {
       return -EINVAL;
    }
--- a/vmnet/vm_assert.h
+++ b/vmnet/vm_assert.h
@@ -40,7 +40,11 @@
 
 // XXX not necessary except some places include vm_assert.h improperly
 #include "vm_basic_types.h"
+
+/* No stdarg.h on Linux kernels 5.15+ */
+#ifndef KBUILD_MODNAME
 #include <stdarg.h>
+#endif
 
 #ifdef __cplusplus
 extern "C" {
--- a/vmnet/vm_basic_defs.h
+++ b/vmnet/vm_basic_defs.h
@@ -50,7 +50,10 @@
  * References:
  *   C90 7.17, C99 7.19, C11 7.19
  */
-#if !defined(VMKERNEL)
+/* Use linux/stddef.h when building Linux kernel modules. */
+#ifdef KBUILD_MODNAME
+#  include <linux/stddef.h>
+#elif !defined(VMKERNEL)
 #  include <stddef.h>
 #else
    /*
--- a/vmnet/vm_basic_types.h
+++ b/vmnet/vm_basic_types.h
@@ -934,6 +934,27 @@
 #define ALIGNED(n)
 #endif
 
+#ifndef __has_attribute
+# define __has_attribute(x) 0
+#endif
+
+/*
+ * COUNTED_BY attribute may be attached to the C99 flexible array
+ * member of a structure. It indicates that the number of the elements
+ * of the array is given by the field "member" in the same structure as
+ * the flexible array member. Compilers may use this information to
+ * improve detection of object size information for such structures
+ * and provide better results in compile-time diagnostics and runtime
+ * features like the array bound sanitizer.
+ *
+ * https://people.kernel.org/kees/bounded-flexible-arrays-in-c
+ */
+
+#if __has_attribute(__counted_by__)
+# define COUNTED_BY(member) __attribute__((__counted_by__(member)))
+#else
+# define COUNTED_BY(member)
+#endif
 
 /*
  * Once upon a time, this was used to silence compiler warnings that
--- a/vmnet/vmnetInt.h
+++ b/vmnet/vmnetInt.h
@@ -41,9 +42,14 @@
     compat_skb_set_network_header(skb, sizeof (struct ethhdr)),  \
     dev_queue_xmit(skb)                                   \
   )
-#define dev_lock_list()    read_lock(&dev_base_lock)
-#define dev_unlock_list()  read_unlock(&dev_base_lock)
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 9, 0)
+#   define dev_lock_list()    rcu_read_lock()
+#   define dev_unlock_list()  rcu_read_unlock()
+#else
+#   define dev_lock_list()    read_lock(&dev_base_lock)
+#   define dev_unlock_list()  read_unlock(&dev_base_lock)
+#endif
 
 extern struct proto vmnet_proto;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0) || defined(sk_net_refcnt)
--- a/vmnet/vnetEvent.c
+++ b/vmnet/vnetEvent.c
@@ -60,10 +60,12 @@
 
 struct VNetEvent_EventNode {
    VNetEvent_EventNode *nextEvent;
-   VNet_EventHeader event;
+   union {
+       VNet_EventHeader header;
+       VNet_LinkStateEvent lse;
+   } event;
 };
 
-#define EVENT_NODE_HEADER_SIZE offsetof(struct VNetEvent_EventNode, event)
 
 struct VNetEvent_Mechanism {
    VNetKernel_SpinLock lock;          /* mechanism lock */
@@ -369,6 +371,10 @@
       return VNetKernel_EINVAL;
    }
 
+   if (e->size > sizeof(p->event)) {
+      return VNetKernel_EINVAL;
+   }
+
    /* lock */
    VNetKernel_SpinLockAcquire(&m->lock);
    m->handlerTask = VNetKernel_ThreadCurrent();
@@ -378,22 +384,15 @@
    while (TRUE) {
        p = *q;
        if (p == NULL ||
-           (p->event.eventId == e->eventId && p->event.type == e->type)) {
+           (p->event.header.eventId == e->eventId && p->event.header.type == e->type)) {
                break;
            }
       q = &p->nextEvent;
    }
 
-   /* remove previously sent event */
-   if (p != NULL && p->event.size != e->size) {
-      *q = p->nextEvent;
-      VNetKernel_MemoryFree(p);
-      p = NULL;
-   }
-
    /* insert new event into event list*/
    if (p == NULL) {
-      p = VNetKernel_MemoryAllocate(EVENT_NODE_HEADER_SIZE + e->size);
+      p = VNetKernel_MemoryAllocate(sizeof(*p));
       if (p == NULL) {
          m->handlerTask = NULL;
          VNetKernel_SpinLockRelease(&m->lock);
@@ -485,8 +484,8 @@
    while (s != NULL) {
       e = s->firstEvent;
       while (e != NULL) {
-         if ((e->event.classSet & classMask) != 0) {
-            h(data, &e->event);
+         if ((e->event.header.classSet & classMask) != 0) {
+            h(data, &e->event.header);
          }
          e = e->nextEvent;
       }
--- a/vmnet/vnetInt.h
+++ b/vmnet/vnetInt.h
@@ -219,6 +219,14 @@
 extern void VNetProc_Cleanup(void);
 
 
+int VNetNetIf_Create(char *devName, VNetPort **ret, int hubNum);
+int VNetUserIf_Create(VNetPort **ret);
+int VNetBridge_Create(const char *devName, uint32 flags, VNetJack *hubJack,
+                      VNetPort **ret);
+int VNetUserListener_Create(uint32 classMask, VNetJack *hubJack,
+                            VNetPort **port);
+
+
 /*
  *----------------------------------------------------------------------
  *
--- a/vmnet/vnetUserListener.c
--- b/vmnet/vnetUserListener.c
@@ -42,10 +42,12 @@
 
 struct VNetUserListener_EventNode {
    VNetUserListener_EventNode *nextEvent;
-   VNet_EventHeader event;
+   union {
+       VNet_EventHeader header;
+       VNet_LinkStateEvent lse;
+   } event;
 };
 
-#define EVENT_NODE_HEADER_SIZE offsetof(struct VNetUserListener_EventNode, event)
 
 typedef struct VNetUserListener {
    VNetPort port;                          /* base port/jack */
@@ -220,7 +222,7 @@
    VNetUserListener_EventNode *t;
 
    /* allocate and initialize event node */
-   t = kmalloc(EVENT_NODE_HEADER_SIZE + e->size, GFP_ATOMIC);
+   t = kmalloc(sizeof *t, GFP_ATOMIC);
    if (t == NULL) {
       LOG(0, (KERN_DEBUG "VNetUserListenerEventHandler, out of memory\n"));
       return;
@@ -299,7 +301,7 @@
    spin_unlock(&userListener->lock);
 
    /* return data and free event */
-   n = t->event.size;
+   n = t->event.header.size;
    if (count < n) {
       n = count;
    }
