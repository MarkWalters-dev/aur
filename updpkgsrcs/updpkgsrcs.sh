#!/usr/bin/env bash

# Return Submodule's Git Command
#
# $_extraArgs: extra args for git submodule update commandline
# $1: "init" or none
function echoGitCMDForSubModule {
    local -A subParent
    local gitCMDName='git '
    for path in "${!subCommit[@]}"; do
        configUrl="-c submodule.${subName[$path]}.url=\"\${srcdir}/${path//\//|}\" \\"
        moduleParent=$path
        while true; do
            moduleParent=${moduleParent%\/*}
            if [[ -f $gitRepo/$moduleParent/.gitmodules ]]; then
                subParent[$moduleParent]+="$configUrl"$'\n'$(printf %"${#gitCMDName}"s); break
            elif [[ $moduleParent == "${moduleParent%\/*}" ]]; then
                subParent[.]+="$configUrl"$'\n'$(printf %"${#gitCMDName}"s); break
            fi
        done
    done
    count=1 && for parent in "${!subParent[@]}"; do
        if [[ $1 == init ]]; then
            echo -e "${gitCMDName}-C '$gitRepo/$parent' submodule init && \\"
        fi
        echo -en "${gitCMDName}${subParent[$parent]}-c protocol.file.allow=always -C '$gitRepo/$parent' submodule update ${_extraArgs}"
        if [ "${#subParent[@]}" == "$count" ]; then echo; else echo " && \\"; fi
        ((count++))
    done
}

declare subModuleSourceTextStart="# Auto generated by '${0##*/}', do not edit."
declare subModuleSourceTextEnd='# End'

# Return Submodule's Source Text
function echoSourceTextForSubModule {
    sourceArrayName='source+=('
    subModuleSourceText+="${subModuleSourceTextStart}"$'\n'"${sourceArrayName}"
    count=1 && for path in "${!subCommit[@]}"; do
        if [[ $path =~ ^(src|pkg|PKGBUILD|.SRCINFO)$ ]]; then
            echo 'TODO: fix submodule that name as src,pkg,PKGBUILD or .SRCINFO.' && exit 1
        fi
        subModule="${path//\//|}::git+${subUrl[$path]}#commit=${subCommit[$path]}"
        if [ "${#subCommit[@]}" == "$count" ]; then
            subModuleSourceText+="'$subModule'"
        else
            subModuleSourceText+="'$subModule'"$'\n'$(printf %"${#sourceArrayName}"s)
        fi
        ((count++))
    done
    subModuleSourceText+=") ${subModuleSourceTextEnd}"
    echo "$subModuleSourceText"
}

# Update source array in PKGBUILD
#
# $1: [Path to PKGBUILD]
function updateBuildScriptForSubModule {
    if buildScriptFile=$(readlink -se "$1"); then
        buildScript=$(cat "$buildScriptFile" 2> /dev/null)
        SourceText="$(echoSourceTextForSubModule)"
        if [[ $buildScript != *$SourceText* ]]; then
            sourceTextForSed=$(echo "$SourceText"|sed -ze 's&\n&\\n&g' -e 's&|&\\|&g')
            sededbuildScript=$(echo "$buildScript" | sed -z "s|\n$subModuleSourceTextStart\nsource+=([^)]*) $subModuleSourceTextEnd\n|\n$sourceTextForSed|")

            if [ "$buildScript" == "$sededbuildScript" ]; then
                echo "$SourceText" >> "$buildScriptFile"
            else
                echo "$sededbuildScript" > "$buildScriptFile"
            fi

            # shellcheck disable=SC2181,SC2320
            if [[ $? != 0 ]]; then
                echo "Failed to update '$buildScriptFile'. The file has not been modified."
            else
                echo "The source of submodules in '$buildScriptFile' have been updated! Please update checksums, then do makepkg again."
            fi && exit 2
        else
            echo "No update for Submodules, continue..." && exit 0
        fi
    else
        echo "Failed to update '$buildScriptFile'. The file is not exist." && exit 1
    fi
}

function printUsage {
	cat <<-EOF
	Update source array of Git submodules in PKGBUILD

	Contain functions:
	"echoSourceTextForSubModule": Echo source array of given Git repository
	"echoGitCMDForSubModule": Echo Git command for PKGBUILD to change submodule's url
	    init: Whether to initialize the submodule, optional if you want to get the submodule of a submodule next time
	    force: Add '--force' parameter to command when update submodule
	"updateBuildScriptForSubModule [Path to PKGBUILD]": Update source array and replace it in PKGBUILD
	    [Path to PKGBUILD]: The PKGBUILD that expected to be modified

	example:
	    $ export _repo="[Path to Git repository]"
	    $ ${0##*/} echoSourceTextForSubModule
	    $ ${0##*/} echoGitCMDForSubModule init force
	    $ ${0##*/} updateBuildScriptForSubModule "[Path to PKGBUILD]"

	EOF
}

declare -A subUrl
declare -A subName
declare -A subPath
declare -A subCommit

# Update arrays about Submodule
function readGitModules {
    gitModules=$(git config -f "$gitRepo/.gitmodules" -l) || return 1

    # Submodule's Commit Array
    gitModulesStatus=$(git -C "$gitRepo" submodule status --recursive --cached) || return 1
    IFS=$'\n' && for line in $gitModulesStatus; do
        line=${line:1}; line=${line% (*)}
        path=${line#* }
        subCommit+=(["$path"]="${line% *}")
        if [[ -f $gitRepo/$path/.gitmodules ]]; then
            gitModules+=$'\n'$(git config -f "$gitRepo/$path/.gitmodules" -l | sed "s#.path=#.path=$path/#g") || return 1
        fi
    done && unset IFS

    # Submodule's Path Array
    IFS=$'\n' && for line in $gitModules; do
        name=${line#submodule.}; name=${name%.*=*}
        if [[ $line =~ .*.path=.* ]]; then
            subName+=(["${line#*.path=}"]="$name") # So we can get name by path
            subPath+=(["$name"]="${line#*.path=}")
        fi
    done && unset IFS

    # Submodule's Url Array
    IFS=$'\n' && for line in $gitModules; do
        name=${line#submodule.}; name=${name%.*=*}
        if [[ $line =~ .*.url=.* ]]; then
            subUrl+=(["${subPath[$name]}"]="${line#*.url=}")
        fi
    done && unset IFS

    # Only support 'path' and 'url'
}

if ! type git > /dev/null 2>&1; then
    echo "This script needs \`git\` in order to work, aborting..." && exit 1
fi

gitRepo=${_repo:-$PWD}
if ! readGitModules; then
    printUsage; echo "No submodule in '$gitRepo', aborting..."; exit 1
fi

case "$1" in
    ForSource)
        ;;
    echoGitCMDForSubModule)
        for arg in "${@:2}"; do
            case "$arg" in
                '')
                    ;;
                force)
                    _extraArgs='--force'
                    ;;
                init)
                    _Args='init'
                    ;;
                *)
                    printUsage && exit 1
                    ;;
            esac
        done
        echoGitCMDForSubModule "$_Args"
        ;;
    echoSourceTextForSubModule)
        echoSourceTextForSubModule
        ;;
    updateBuildScriptForSubModule)
        updateBuildScriptForSubModule "${2:-$gitRepo/../../PKGBUILD}" # The path to PKGBUILD in most case
        ;;
    *)
        printUsage && exit 1
        ;;
esac
